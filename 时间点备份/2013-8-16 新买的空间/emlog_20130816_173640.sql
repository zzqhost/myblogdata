#version:emlog 5.1.2
#date:2013-08-16 17:36
#tableprefix:emlog_
DROP TABLE IF EXISTS emlog_attachment;
CREATE TABLE `emlog_attachment` (
  `aid` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `blogid` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `filename` varchar(255) NOT NULL DEFAULT '',
  `filesize` int(10) NOT NULL DEFAULT '0',
  `filepath` varchar(255) NOT NULL DEFAULT '',
  `addtime` bigint(20) NOT NULL DEFAULT '0',
  `width` smallint(5) NOT NULL DEFAULT '0',
  `height` smallint(5) NOT NULL DEFAULT '0',
  `mimetype` varchar(40) NOT NULL DEFAULT '',
  `thumfor` smallint(5) NOT NULL DEFAULT '0',
  PRIMARY KEY (`aid`),
  KEY `blogid` (`blogid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;


DROP TABLE IF EXISTS emlog_blog;
CREATE TABLE `emlog_blog` (
  `gid` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL DEFAULT '',
  `date` bigint(20) NOT NULL,
  `content` longtext NOT NULL,
  `excerpt` longtext NOT NULL,
  `alias` varchar(200) NOT NULL DEFAULT '',
  `author` int(10) NOT NULL DEFAULT '1',
  `sortid` tinyint(3) NOT NULL DEFAULT '-1',
  `type` varchar(20) NOT NULL DEFAULT 'blog',
  `views` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `comnum` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `tbcount` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `attnum` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `top` enum('n','y') NOT NULL DEFAULT 'n',
  `hide` enum('n','y') NOT NULL DEFAULT 'n',
  `allow_remark` enum('n','y') NOT NULL DEFAULT 'y',
  `allow_tb` enum('n','y') NOT NULL DEFAULT 'y',
  `password` varchar(255) NOT NULL DEFAULT '',
  PRIMARY KEY (`gid`),
  KEY `date` (`date`),
  KEY `author` (`author`),
  KEY `sortid` (`sortid`),
  KEY `type` (`type`),
  KEY `views` (`views`),
  KEY `comnum` (`comnum`),
  KEY `hide` (`hide`)
) ENGINE=MyISAM AUTO_INCREMENT=43 DEFAULT CHARSET=utf8;

INSERT INTO emlog_blog VALUES('8','将Android源代码导入到Eclipse中','1373374587','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. 说明\n</h2>\n<p style=\"color:#000000;text-indent:0px;\">\n	研究Android上层代码，最便捷的方式无疑是将它们导入到Eclipse中来进行查看，包括感兴趣的各种App，及frameworks中的代码等，下面就将此步骤详细说明一下：\n</p>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. 步骤\n</h2>\n<ol style=\"color:#000000;text-indent:0px;\">\n	<li>\n		把Android代码的Eclipse工程配置文件复制到android源码根目录下\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ cp development/ide/eclipse/.classpath ./\n			</li>\n		</ul>\n	</li>\n	<li>\n		修改eclipse程序的配置\n		<ul style=\"margin-left:2em;\">\n			<li>\n				修改eclipse缓存设置: 把eclipse.ini（在eclipse软件的安装目录下）的3个值改为下面的值\n				<ul style=\"margin-left:2em;\">\n					<li>\n						-Xms128m\n					</li>\n					<li>\n						-Xmx512m\n					</li>\n					<li>\n						-XX:MaxPermSize=256m\n					</li>\n					<li>\n						说明\n						<ul style=\"margin-left:2em;\">\n							<li>\n								JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.\n							</li>\n							<li>\n								JVM在启动的时候会自动设置Heap size的值\n							</li>\n							<li>\n								其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。\n							</li>\n							<li>\n								如果在导入过程中出现 java heap space， 可以尝试把上面的值改大， 我在导入Android4.1代码时就发生了此错误。\n							</li>\n						</ul>\n					</li>\n				</ul>\n			</li>\n			<li>\n				修改Eclipse的代码风格等：\n				<ul style=\"margin-left:2em;\">\n					<li>\n						相关文件介绍\n						<ul style=\"margin-left:2em;\">\n							<li>\n								可以简单的将android-formatting.xml和android.importorder导入eclipse\n							</li>\n							<li>\n								位置： android-formatting.xml、.classpath和android.importorder都放在development/ide/eclipse/下\n							</li>\n							<li>\n								android-formatting.xml用来配置eclipse编辑器的代码风格\n							</li>\n							<li>\n								android.importorder用来配置eclipse的import的顺序和结构。\n							</li>\n						</ul>\n					</li>\n					<li>\n						导入方法\n						<ul style=\"margin-left:2em;\">\n							<li>\n								在window-&gt;preferences-&gt;java-&gt;Code style-&gt;Formatter中导入android-formatting.xml\n							</li>\n							<li>\n								在window-&gt;preferences-&gt;java-&gt;Code style-&gt;Organize Imports中导入android.importorder\n							</li>\n						</ul>\n					</li>\n				</ul>\n			</li>\n		</ul>\n	</li>\n	<li>\n		把android源码作为一个工程导入eclipse\n		<ul style=\"margin-left:2em;\">\n			<li>\n				注意：导入前先检查.classpath里的文件在android源码中是否有相应的文件（文件夹），否则会破坏android源码（一般是多添加文件/文件夹），.classpath里多余的路径可删除\n			</li>\n			<li>\n				最好重新换一个workspace，因为源码是比较庞大的。新建Java Project(不是android project，否则会破坏android源码)，指定一个name，接着将use default location勾掉，指定到你源码的目录下，finish。\n			</li>\n		</ul>\n	</li>\n</ol>','<p>\n	1. 说明\n</p>\n<p>\n	<br />\n</p>\n<p>\n	研究Android上层代码，最便捷的方式无疑是将它们导入到Eclipse中来进行查看，包括感兴趣的各种App，及frameworks中的代码等，下面就将此步骤详细说明一下：\n</p>\n<p>\n	2. 步骤\n</p>\n<p>\n	<br />\n</p>\n<p>\n	把Android代码的Eclipse工程配置文件复制到android源码根目录下\n</p>\n<p>\n	$ cp development/ide/eclipse/.classpath ./\n</p>\n<p>\n	<br />\n</p>','','2','2','blog','7','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('7','CTS测试环境搭建及简易步骤','1373374548','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. CTS是什么\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		想必看到这里的同学都知道CTS是什么吧，不知道的话，自行Google，或者就不必往下看了。\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. 下载CTS测试包及手册\n</h2>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\n	2.1. 下载\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		<strong>地址：</strong> <a href=\"http://source.android.com/compatibility/downloads.html\">http://source.android.com/compatibility/downloads.html</a> \n	</li>\n	<li>\n		最新的CTS测试自动测试包手工测试包。\n	</li>\n	<li>\n		在最下方有 The CTS User Manual\n	</li>\n</ul>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\n	2.2. 配置环境\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		看下载的cts包路径下的：/android-cts/tools/README，顺着它接着看下载的用户手册，主要的一些配置步骤如下：\n		<ul style=\"margin-left:2em;\">\n			<li>\n				Set up accessibility tests:\n				<ol>\n					<li>\n						# adb install android-cts/repository/testcases/CtsDelegatingAccessibilityService.apk\n					</li>\n					<li>\n						On the device, enable Settings &gt; Accessibility &gt; Delegating Accessibility Service\n					</li>\n				</ol>\n			</li>\n			<li>\n				Set up device administration tests:\n				<ol>\n					<li>\n						# adb install android-cts/repository/testcases/CtsDeviceAdmin.apk\n					</li>\n					<li>\n						On the device, enable Settings &gt; Security &gt; Device Administrators &gt; android.deviceadmin.cts.CtsDeviceAdmin* settings\n					</li>\n				</ol>\n			</li>\n			<li>\n				安装要测试的apk， 比如\n				<ol>\n					<li>\n						# adb install /testcases/CtsMediaTestCases.apk\n					</li>\n				</ol>\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\n	3. 开始测试\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		在路径 android-cts/tools/ 下运行命令 cts-tradefed\n	</li>\n	<li>\n		然后在命令行下动行 run cts --class android.media.cts.DecoderTest *\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\n	4. 结果\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		最后，测试的结果及Log会存放到 android-cts/repository 下\n	</li>\n</ul>','<p>\n	1. CTS是什么\n</p>\n<p>\n	<br />\n</p>\n<p>\n	想必看到这里的同学都知道CTS是什么吧，不知道的话，自行Google，或者就不必往下看了。\n</p>\n<p>\n	2. 下载CTS测试包及手册\n</p>\n<p>\n	<br />\n</p>\n<p>\n	2.1. 下载\n</p>\n<p>\n	<br />\n</p>\n<p>\n	地址： http://source.android.com/compatibility/downloads.html\n</p>\n<p>\n	最新的CTS测试自动测试包手工测试包。\n</p>\n<p>\n	在最下方有 The CTS User Manual\n</p>\n<p>\n	2.2. 配置环境\n</p>\n<p>\n	<br />\n</p>','','2','2','blog','4','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('6','Ubuntu下编译安装OpenCV并配置QTCreater','1373374478','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. 编译安装\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		首先在终端运行下列命令进行必要的编译环境安装\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg62-dev libtiff4-dev cmake libswscale-dev libjasper-dev\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		下载相应的版本到电脑里面，这里我们以下载OpenCV-2.4.3为例\n	</li>\n	<li>\n		解压并配置编译环境\n		<ul style=\"margin-left:2em;\">\n			<li>\n				解压 OpenCV-2.3.1.tar.bz2\n			</li>\n			<li>\n				$ cd OpenCV-2.3.1\n			</li>\n			<li>\n				$ mkdir build\n			</li>\n			<li>\n				$ cd build\n			</li>\n			<li>\n				$ cmake .. (此处为cmake空格后面两个点,即上级目录, 你懂的....)\n			</li>\n		</ul>\n	</li>\n	<li>\n		编译安装\n		<ul style=\"margin-left:2em;\">\n			<li>\n				make\n			</li>\n			<li>\n				sudo make install\n			</li>\n		</ul>\n	</li>\n	<li>\n		安装后的路径为: (可以在cmake那一步观察到)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				/usr/local/include/opencv/\n			</li>\n			<li>\n				/usr/local/include/opencv2/\n			</li>\n			<li>\n				/usr/local/lib/\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		配置必要的库\n		<ul style=\"margin-left:2em;\">\n			<li>\n				sudo gedit /etc/ld.so.conf.d/opencv.conf\n			</li>\n			<li>\n				添加这句命令到文件中，文件或许是空的，不影响. /usr/local/lib/\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		运行此命令\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ sudo ldconfig\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		现在运行这条命令 sudo gedit /etc/bash.bashrc，添加下面两行到文件的末尾并保存。\n		<ol>\n			<li>\n				PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig\n			</li>\n			<li>\n				export PKG_CONFIG_PATH\n			</li>\n		</ol>\n	</li>\n	<li>\n		运行完毕后，需要注销一下系统，否则设置不会生效。\n	</li>\n	<li>\n		注销归来，opencv已经安装成功了\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. 配置QTCreater并运行例程测试\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		将opencv库加入到qtcreator里\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ sudo gedit /usr/share/qt4/mkspecs/default/qmake.conf\n			</li>\n			<li>\n				在文件内添加了下面两句：\n				<ol>\n					<li>\n						QMAKE_INCDIR = /usr/include/opencv\n					</li>\n					<li>\n						QMAKE_LIBS = -lcvaux -lcv -lcxcore -lhighgui -lml\n					</li>\n				</ol>\n			</li>\n		</ul>\n	</li>\n	<li>\n		新建QT工程, 在这里我建了一个纯C++的工程取名为testopencv.\n	</li>\n	<li>\n		在testopencv.pro文件内添加：\n<pre>INCLUDEPATH += /usr/local/include/opencv\nLIBS += \\\n/usr/local/lib/libopencv_core.so \\\n/usr/local/lib/libopencv_highgui.so \\\n/usr/local/lib/libopencv_ml.so\n</pre>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		输入以下代码,编译运行\n<pre>#include#include <cv.h>\n#include <highgui.h>\n\nusing namespace std;\n\nint main()\n{\n    IplImage *img = 0;\n    img = cvLoadImage(\"/home/zzq/Desktop/test2.jpg\", -1);\n    cvNamedWindow(\"test\", CV_WINDOW_NORMAL);\n    cvShowImage(\"test\", img);\n    cvWaitKey(0);\n    return 0;\n}\n\n</highgui.h></cv.h></pre>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		注: 在网上,有文章说可以把 pro文件中的配置放到 qmake.conf 中, 但是我试过,没有成功, 可能是放的配置文件不正确,或者是写法不正确, 有空了再研究一下.\n	</li>\n</ul>','<p>\n	1. 编译安装\n</p>\n<p>\n	<br />\n</p>\n<p>\n	首先在终端运行下列命令进行必要的编译环境安装\n</p>\n<p>\n	$ sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg62-dev libtiff4-dev cmake libswscale-dev libjasper-dev\n</p>\n<p>\n	下载相应的版本到电脑里面，这里我们以下载OpenCV-2.4.3为例\n</p>\n<p>\n	解压并配置编译环境\n</p>\n<p>\n	解压 OpenCV-2.3.1.tar.bz2\n</p>\n<p>\n	$ cd OpenCV-2.3.1\n</p>\n<p>\n	$ mkdir build\n</p>\n<p>\n	$ cd build\n</p>\n<p>\n	$ cmake .. (此处为cmake空格后面两个点,即上级目录, 你懂的....)\n</p>\n<p>\n	编译安装\n</p>\n<p>\n	make\n</p>\n<p>\n	sudo make install\n</p>\n<p>\n	安装后的路径为: (可以在cmake那一步观察到)\n</p>','','2','3','blog','3','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('9','配置Android开发环境','1373374653','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. 前期准备\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		首先，这里讲的是Ubuntu上如何配置。 ubuntu的版本为12.04或10.04均可, 需要64位。\n	</li>\n	<li>\n		已经下载下来了Android代码，如还没下载，请参考<a href=\"http://zzqhost.com/程序设计_Android_环境配置_如何下载Android源码.html\">如何下载Android源码</a>来下载代码。我这里用的代码版本是Android4.1 JellyBean.\n	</li>\n	<li>\n		好了，开始配置了...\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. 步骤\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		首先切换到root权限，以方便后续的操作\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ sudo su\n			</li>\n		</ul>\n	</li>\n	<li>\n		安装需要的软件包（include git and subversion）\n<pre>aptitude -y install ant binutils binutils-dev binutils-static \\\nlibncurses5-dev libncursesw5-dev ncurses-term ncurses-hexedit openssh-server \\\ngcc-4.2 g++-4.2 libstdc++5 libstdc++6-4.2 automake1.8 automake1.9 dialog libltdl3 \\\nbuild-essential libz-dev flex gperf libwxgtk2.6-dev libcurses-widgets-perl bison \\\nlibcurses-perl libcurses-ui-perl libcurses-ruby libcurses-ruby1.8 python2.5 \\\nlibsdl-dev valgrind ncurses-dev libtool libx11-dev vim vim-full exuberant-ctags \\\nmeld pbzip2 wget wmii2 dwm bison htop iotop zip unzip fakeroot sun-java6-jdk \\\ncramfsprogs screen sysv-rc-conf subversion subversion-tools python-svn \\\npython-soappy git git-core git-svn sun-java6-jdk p7zip p7zip-full xlockmore \\\nmingw32 tofrodos tig tmux libsvn-perl sshfs gnuplot tree libc6-dev-i386 \\\nlib32z1-dev lib32ncurses5-dev libzzip-dev libc6-dev-amd64 g++-multilib \\\nlib64stdc++6 lib64z1-dev ia32-libs-sdl mutt txt2html splint squashfs-tools \\\nkpartx lsb-release tmux linux-server gnupg curl zlib1g-dev gcc-multilib \\\nx11proto-core-dev lib32readline5-dev lib32z-dev gawk cscope libqtcore4 \\\nxml2 wmctrl ant1.8\n</pre>\n	</li>\n</ul>\n<pre>    ln -s /usr/bin/fromdos /usr/local/bin/dos2unix\n</pre>\n<pre>    aptitude -y purge nbSMTP exim4 exim4-base exim4-daemon-light\n</pre>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		安装JDK1.6，并配置PATH变量\n		<ul style=\"margin-left:2em;\">\n			<li>\n				首先，从网上下载最新版本的JDK1.6， 我下载的版本是：jdk-6u33-linux-x64.bin\n			</li>\n			<li>\n				安装\n				<ul style=\"margin-left:2em;\">\n					<li>\n						$ chmod 777 jdk-6u33-linux-x64.bin\n					</li>\n					<li>\n						$ ./jdk-6u33-linux-x64.bin\n					</li>\n				</ul>\n			</li>\n			<li>\n				把上步解开的文件夹移动到系统路径中,并建立链接\n				<ul style=\"margin-left:2em;\">\n					<li>\n						$ mv jdk1.6.0_33 /usr/local\n					</li>\n					<li>\n						$ ln -s /usr/local/jdk1.6.0_33 /usr/local/jdk1.6\n					</li>\n				</ul>\n			</li>\n			<li>\n				配置PATH\n<pre>echo \" PATH=/usr/local/jdk1.6/bin:/usr/local/arm-linux/bin:\\$PATH:\nCLASSPATH=/usr/local/jdk1.6/lib:.\nJAVA_HOME=/usr/local/jdk1.6\nexport PATH CLASSPATH JAVA_HOME\nalias vi=vim\nalias h=htop\nalias screen=\'screen -R -DD\'\nexport VISUAL=vim\" &gt;&gt;/etc/bash.bashrc\n</pre>\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\n	3. 编译\n</h2>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\n	3.1. 配置编译环境\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		$ . build/envsetup.sh （注意 . 后的空格）\n	</li>\n	<li>\n		$ lunch (全部采用默认，直接回车)\n	</li>\n</ul>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.2\">\n	3.2. Building\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		编译全部代码(可不用配置上步的编译环境)： 源码路径下执行以下命令\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ make -j4\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		按模块编译(可不用配置上步的编译环境)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ make mediaserver\n			</li>\n			<li>\n				$ make frameworks\n			</li>\n			<li>\n				模块编译会自动处理相关的一些依赖库。\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		按路径编译部分代码(在源码根路径下, 必须配置上步编译环境)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ mmm frameworks/av/media/libstagefright/\n			</li>\n			<li>\n				$ mmm framworks/base/\n			</li>\n			<li>\n				此种方法只编译此路径下的代码，必须要有Android.mk,如果是java代码可不需要。\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		编译完之后，如果需要把刚编译好的一个so或apk之类的烧到模拟器中，则运行下述命令\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ make snod\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\n	4. 运行模拟器\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		只运行模拟器, 在源码路径下执行以下命令：\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ . build/envsetup.sh\n			</li>\n			<li>\n				$ lunch\n			</li>\n			<li>\n				$ emulator &amp;\n			</li>\n		</ul>\n	</li>\n	<li>\n		带SD卡启动\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ . build/envsetup.sh\n			</li>\n			<li>\n				$ lunch\n			</li>\n			<li>\n				$ emulator -sdcard ~/work/andord_lx/sdcard/sdcard.img &amp;\n			</li>\n		</ul>\n	</li>\n	<li>\n		带SD卡启动大屏幕\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ . build/envsetup.sh\n			</li>\n			<li>\n				$ lunch\n			</li>\n			<li>\n				$ emulator -sdcard ~/work/andord_lx/sdcard/sdcard.img -skin NGB720P &amp;\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.5\">\n	5. 安装软件并播放SD卡上的视频\n</h2>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.5.1\">\n	5.1. 创建SD卡\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		例如创建一个名为sdcard.img的128M(M需大写）SD卡镜像到~/work/android_lx/sdcard/下\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ cd ~/work\n			</li>\n			<li>\n				$ mkdir android_lx/sdcard -p\n			</li>\n			<li>\n				$ cd android_lx/sdcard\n			</li>\n			<li>\n				$ mksdcard 128M sdcard.img\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		如果提示找不到mksdcard命令，则需要在源码路径下执行以下命令：\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ . build/envsetup.sh\n			</li>\n			<li>\n				$ lunch\n			</li>\n		</ul>\n	</li>\n</ul>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.5.2\">\n	5.2. 向emulator的SD卡镜像写入数据\n</h3>\n<ol style=\"color:#000000;text-indent:0px;\">\n	<li>\n		方法一(速度快，推荐)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ sudo mkdir /mnt/sdcard\n			</li>\n			<li>\n				$ sudo mount -o loop ~/work/android_lx/sdcard/sdcard.img /mnt/sdcard/\n			</li>\n			<li>\n				$ sudo cp ~/Video/shrek.mkv /mnt/sdcard/\n			</li>\n			<li>\n				$ ls -al /mnt/sdcard/\n			</li>\n			<li>\n				$ sudo umount /mnt/sdcard\n			</li>\n		</ul>\n	</li>\n	<li>\n		方法二(速度慢，直观)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ emulator -sdcard ~/work/android_lx/sdcard.img &amp;\n			</li>\n			<li>\n				$ adb push ~/Video/hahan.mp4 /sdcard\n			</li>\n			<li>\n				$ adb shell\n			</li>\n			<li>\n				$ ls /sdcard/ -l\n			</li>\n		</ul>\n	</li>\n</ol>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.5.3\">\n	5.3. 模拟器挂载SD卡镜像\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		$ emulator -sdcard ~/work/andord_lx/sdcard/sdcard.img &amp;\n	</li>\n</ul>\n<p style=\"color:#000000;text-indent:0px;\">\n	这样启动模拟器后，模拟器就不会抱怨没有SD卡了。\n</p>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.5.4\">\n	5.4. 安装apk包\n</h3>\n<p style=\"color:#000000;text-indent:0px;\">\n	在确保模拟器已经启动的情况下\n</p>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		$ adb install ~/work/android_lx/SeeJoPlayer.apk\n	</li>\n</ul>\n<p style=\"color:#000000;text-indent:0px;\">\n	如果提示找不到adb命令，则需要在源码路径下执行以下命令：\n</p>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		$ . build/envsetup.sh\n	</li>\n	<li>\n		$ lunch\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.6\">\n	6. 模拟器的相关操作\n</h2>\n<ol style=\"color:#000000;text-indent:0px;\">\n	<li>\n		进入Android shell\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ adb shell\n			</li>\n		</ul>\n	</li>\n	<li>\n		在模拟器中打印LOG\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ logcat\n			</li>\n		</ul>\n	</li>\n	<li>\n		退出模拟器shell\n		<ul style=\"margin-left:2em;\">\n			<li>\n				$ exit\n			</li>\n		</ul>\n	</li>\n	<li>\n		调整横坚屏\n		<ul style=\"margin-left:2em;\">\n			<li>\n				Ctrl+F12\n			</li>\n		</ul>\n	</li>\n</ol>','<p>\n	1. 前期准备\n</p>\n<p>\n	<br />\n</p>\n<p>\n	首先，这里讲的是Ubuntu上如何配置。 ubuntu的版本为12.04或10.04均可, 需要64位。\n</p>\n<p>\n	已经下载下来了Android代码，如还没下载，请参考如何下载Android源码来下载代码。我这里用的代码版本是Android4.1 JellyBean.\n</p>\n<p>\n	好了，开始配置了...\n</p>\n<p>\n	2. 步骤\n</p>\n<p>\n	<br />\n</p>\n<p>\n	首先切换到root权限，以方便后续的操作\n</p>\n<p>\n	$ sudo su\n</p>\n<p>\n	安装需要的软件包（include git and subversion）\n</p>','','2','2','blog','106','2','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('10','查看网络状态命令','1373374680','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. Android手机网络开发中有用的命令\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		查看网络包\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				tcpdump -i wlan0\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		查看网络当前的状态\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				netstat\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		过滤条件\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				iw phy phy0 wowlan show\r\n			</li>\r\n			<li>\r\n				iw phy phy0 wowlan disable\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. Android手机网络开发中有用的命令\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	查看网络包\r\n</p>\r\n<p>\r\n	tcpdump -i wlan0\r\n</p>\r\n<p>\r\n	查看网络当前的状态\r\n</p>\r\n<p>\r\n	netstat\r\n</p>\r\n<p>\r\n	过滤条件\r\n</p>\r\n<p>\r\n	iw phy phy0 wowlan show\r\n</p>\r\n<p>\r\n	iw phy phy0 wowlan disable\r\n</p>','','2','2','blog','10','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('11','SkipCutBuffer的研究','1373374730','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. SkipCutBuffer是什么\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		今天研究Android源码突然发现了一个SkipCutBuffer类，以前从来没见过，赶紧看了一下Andoir4.0.3, 发现是没有这个东东的，原来是Android4.1是新增的功能。\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		那它有什么用呢，搜索了一下，发现两个地方用到它了。 OMXCodec和ACodec。\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		再进一步查看Google的Git提交记录。 Gitk一下，哈哈，找到啦，解释如下：\n	</li>\n</ul>\n<blockquote style=\"color:#000000;text-indent:0px;background-color:#F6F5EB;\">\n	<p>\n		Support gapless playback for mp3 and m4a\n	</p>\n</blockquote>\n<blockquote style=\"color:#000000;text-indent:0px;background-color:#F6F5EB;\">\n	<p>\n		Gapless playback for appropriately tagged mp3 and m4a files. Currently this is implemented in OMXCodec, which most players use, but should be easy to support in other players as well by using the SkipCutBuffer utility class.\n	</p>\n</blockquote>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		那什么是gapless playback呢？\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. 什么是gapless playback\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		对于有要求的音乐爱好者，是否支持gapless playback是判定优秀播放器的重要标准。所谓gapless playback是指在声轨和声轨之间没有间隙，这对听古典音乐，歌剧和现场录音特别重要。比如贝多芬第五交响乐的第3和第4乐章之间就是应该无间隙的。 (摘自于 \"_<em>音乐播放器 Pocket Music Player Bundle v5.3.5 汉化版</em>_\" 的说明)\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		看来Google的Stagefright越来越完善啦，连gapless playback都开始支持了。\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\n	3. 分析SkipCutBuffer源码\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		好了现在开始分析一下SkipCutBuffer的源码吧，这里最好画个图就好了，但是vimwiki中画图不太方便，直接描述吧，说清楚就行了。\n		<ul style=\"margin-left:2em;\">\n			<li>\n				此类有两个参数skip和cut,(所以叫SkipCutBuffer，哈哈），skip指的是当前音乐最头需要扔几个字节的数据，cut指的是此音乐播放到最后需要扔几个字节的数据。\n			</li>\n			<li>\n				无缝播放应该就是这种模式：前一个首音乐和后一首连起来，中间没有停顿，SkipCutBuffer用扔前后一点数据来实现，算法很简单是不是<sup>_</sup> \n			</li>\n			<li>\n				用的时候呢，只对第一帧丢弃一点点数据(skip)，然后对于每一帧数据均需要切割，把后边的cut长度的数据不进行播放，留到一下帧数据去。如果是最后一帧数据会发生什么情况呢，哈哈～～\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		用法：在Stagefright中，总共有两处用到了SkipCutBuffer: OMXCodec和ACodec, 都比较简单，这里就不说了。 ACodec的用法还有一个错误，呵呵～\n	</li>\n</ul>','<p>\n	1. SkipCutBuffer是什么\n</p>\n<p>\n	<br />\n</p>\n<p>\n	今天研究Android源码突然发现了一个SkipCutBuffer类，以前从来没见过，赶紧看了一下Andoir4.0.3, 发现是没有这个东东的，原来是Android4.1是新增的功能。\n</p>\n<p>\n	那它有什么用呢，搜索了一下，发现两个地方用到它了。 OMXCodec和ACodec。\n</p>\n<p>\n	再进一步查看Google的Git提交记录。 Gitk一下，哈哈，找到啦，解释如下：\n</p>','','2','1','blog','7','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('12','HTTP Progressive Streaming 分析','1373374759','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\n	1. 数据源设置DataSource\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		对于http progressive download模式的数据源，分为两步完成：\n		<ol>\n			<li>\n				客户端调用setDataSource(const char*uri, …)后，AwesomePlayer保存了uri的值，其实没有做什么实质的事情，也没有发起连接。真正的连接网络并sniff的过程是在prepare的时候才进行的。\n			</li>\n			<li>\n				客户端调用prepare，AwesomePlayerpost一个onPrepareAsyncEvent事件，在其回调函数中调用finishSetDataSource_l函数，发起连接获取源的文件头，读取文件头的MIMETYPE信息，再根据MIMETYPE信息创建相应的MediaExtractor。最后这个MediaExtractor才是AwesomePlayer的数据源。读取原始数据源的dataSource将委托给MediaExtractor来调用。AwesomePlayer只从MediaExtractor中读取已经extract过的数据。\n			</li>\n		</ol>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		在finishSetDataSource_l中，用到了几个DataSource\n		<ol>\n			<li>\n				NuCachedSource2\n				<ul style=\"margin-left:2em;\">\n					<li>\n						带缓存的DataSource，不包含媒体信息，只管理缓存以及调用底层的DataSource读取和缓存数据。可以获取缓存的信息以及操作缓存。\n					</li>\n				</ul>\n			</li>\n			<li>\n				HTTPBase\n				<ul style=\"margin-left:2em;\">\n					<li>\n						基于http连接的DataSource，具有带宽管理功能，没有实现http连接功能\n					</li>\n				</ul>\n			</li>\n			<li>\n				ChromiumHTTPDataSource\n				<ul style=\"margin-left:2em;\">\n					<li>\n						HTTPBase的子类，真正操作和管理http连接及状态。ChromiumHTTPDataSource本身也不会直接操作socket，而是采用SfDelegate作为http协议栈来进行http连接的发起和关闭，本身通过注册回调函数(onConnectionEstablished, onDisconnectComplete等)来获取连接信息。ChromiumHTTPDataSource不进行缓存管理，如果调用readAt，将直接调用SfDelegate，如果需要连接就发起连接，可见如果没有缓存管理每次直接操作ChromiumHTTPDataSource将有可能不断发起网络连接造成性能低下。\n					</li>\n				</ul>\n			</li>\n		</ol>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		finishSetDataSource_l函数中设置数据源的真正操作如下\n		<ol>\n			<li>\n				首先设置连接源\n				<ol>\n					<li>\n						如果是Widevine 协议的DRM，由于没有缓存，直接使用HTTPBase\n					</li>\n					<li>\n						其它形式的Http progressive download使用NuCachedSource2\n					</li>\n					<li>\n						对于视频源，首先下载至少192KB(192x1024)字节的文件缓存用于Sniff文件头，\n					</li>\n				</ol>\n			</li>\n			<li>\n				Sniff到文件头信息后，获取MIMETYPE，并创建相应的MediaExtractor，再次调用setDataSource_l(extractor);至此DataSource正式建立完成。\n			</li>\n		</ol>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\n	2. ChromiumHTTPDataSource中的PageCache缓存数据结构\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		PageCache包含两个page list: active pages和 free pages:\n		<ol>\n			<li>\n				List<page*> mActivePages; 保存了有效数据的缓存，其中的连续的list构成了一段连续的媒体内容</page*>\n			</li>\n			<li>\n				List<page*> mFreePages; 可用缓存，可能是有数据但是已经无效的内存，或者是空内存</page*>\n			</li>\n		</ol>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		PageCache初始化时就确定了每个Page的最大size：\n<pre>    PageCache::PageCache(size_t pageSize)\n        : mPageSize(pageSize), mTotalSize(0) {\n\n    }\n\n</pre>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		获取一个可用的page： acquirePage\n		<ul style=\"margin-left:2em;\">\n			<li>\n				rator从free pages中获取第一个page，并从free pages中删除该page。如果没有则直接malloc一个。\n			</li>\n		</ul>\n	</li>\n	<li>\n		获取到page后，通过page data指针往里面填充数据，再调用appendPage将page加入到active pages中。\n	</li>\n	<li>\n		释放缓存： releasePage\n		<ul style=\"margin-left:2em;\">\n			<li>\n				releasePage时并不free指针，也不从active pages中移除。只是清空size信息并将page放到freePages中以便下次重用。由此可见整个cache实际占用内存的大小应该是非递减的，等于运行过程中占用内存的最大值。（WHY?）由于page cache中的list代表的是连续媒体，因此不能release list中间的一个page,只能release list头部或尾部的page。\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		整个cache中数据量保存在PageCache的mTotalSize中，每次appendPage时累加当前page中的实际数据量(mSize)。\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\n	3. NuCachedSource2读取网络\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		如何驱动\n		<ul style=\"margin-left:2em;\">\n			<li>\n				NuCachedSource2被创建（new）时就立即post了一个kWhatFetchMore消息，onFetch调用最后语句又post了一个kWhatFetchMore，并且此前没有return语句，所以可见在NuCachedSource2的生存期内，kWhatFetchMore是个一直存在的循环驱动事件，但是事件post的delay时间不一样，如果是重试，delay 3s, 如果是空闲状态，delay 100ms。\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		HighwaterThresholdBytes\n		<ul style=\"margin-left:2em;\">\n			<li>\n				当cache数据大于mHighwaterThresholdBytes时，停止fetch，并根据设置决定是否disconnect(). 默认20KB\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		LowwaterThresholdBytes\n		<ul style=\"margin-left:2em;\">\n			<li>\n				restartPrefetcher中判断当cache的数据量大于阈值mLowwaterThresholdBytes时，就不再prefetch了。默认4KB.\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\n	4. 数据获取\n</h2>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.4.1\">\n	4.1. keepAlive\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		应该是针对有session的http连接，通过ALooper::GetNowUs计时，每隔mKeepAliveIntervalUs时间将调用fetchIntenal()保持与server的连接。默认间隔设置为15s。\n	</li>\n</ul>\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.4.2\">\n	4.2. 预取数据：restartPrefetcherIfNecessary_l\n</h3>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		几个变量：\n		<ul style=\"margin-left:2em;\">\n			<li>\n				Lastaccess position (mLastAccessPos): 表示数据调用者最后一次读取的位置，\n			</li>\n			<li>\n				Cacheoffset (mCacheOffset): Cache数据在整个源数据文件中的偏移位置。\n			</li>\n		</ul>\n	</li>\n</ul>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		void NuCachedSource2::restartPrefetcherIfNecessary_l(bool ignoreLowWaterThreshold, bool force)\n		<ul style=\"margin-left:2em;\">\n			<li>\n				Prefetch操作相当于随着播放的进行cache也会自动往前进行，每次prefetch释放当前page cache中已经播放过的的active pages，并更新cache offset至合适的位置。\n			</li>\n			<li>\n				ignoreLowWaterThreshold： 当cache的数据量大于阈值mLowwaterThresholdBytes时，就不再prefetch了。\n			</li>\n			<li>\n				force\n				<ul style=\"margin-left:2em;\">\n					<li>\n						last access与Cache偏移位置之间可以保留一个kGrayArea大小的数据，这部分数据是已经访问过的数据，理论上可以被忽略并释放，但考虑到seek或其它操作（如带Bframe的媒体？）中会再次用到，如果释放的话会引起再次重连网络获取影响性能，因此在保留不释放。force变量用于控制释放cache时，是否保留gray area.\n					</li>\n				</ul>\n			</li>\n		</ul>\n	</li>\n</ul>\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.5\">\n	5. 读取数据源readAt\n</h2>\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\n	<li>\n		原型： readAt(off64_toffset, void *data, size_t size)\n	</li>\n	<li>\n		NuCachedSource2会首先在cache中查找offset和size是否能被满足（再次注意，cache中的多个page代表的是连续的媒体内容）\n	</li>\n	<li>\n		如果满足，直接从cache中拷贝到目标指针并返回，否则post一个kWhatRead消息，调用线程被阻塞（condition.wait()）。\n	</li>\n	<li>\n		onRead()回调: 调用readInternal，返回-EAGAIN时，延迟50ms继续发送kWhatRead消息。直到成功或者返回IO错误时，broadcast解除阻塞中的调用线程。\n	</li>\n	<li>\n		readInternal(): 调用restartPrefetcherIfNecessary_l进行数据预取，如果不满足read条件（offset,size）则返回-EAGAIN，成功则拷贝目标数据。\n	</li>\n</ul>','<p>\n	1. 数据源设置DataSource\n</p>\n<p>\n	<br />\n</p>\n<p>\n	对于http progressive download模式的数据源，分为两步完成：\n</p>\n<p>\n	客户端调用setDataSource(const char*uri, …)后，AwesomePlayer保存了uri的值，其实没有做什么实质的事情，也没有发起连接。真正的连接网络并sniff的过程是在prepare的时候才进行的。\n</p>\n<p>\n	客户端调用prepare，AwesomePlayerpost一个onPrepareAsyncEvent事件，在其回调函数中调用finishSetDataSource_l函数，发起连接获取源的文件头，读取文件头的MIMETYPE信息，再根据MIMETYPE信息创建相应的MediaExtractor。最后这个MediaExtractor才是AwesomePlayer的数据源。读取原始数据源的dataSource将委托给MediaExtractor来调用。AwesomePlayer只从MediaExtractor中读取已经extract过的数据。\n</p>','','2','1','blog','5','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('13','常用代码及其存放位置备忘','1373374790','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 错误值\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.1\">\r\n	1.1. 文件汇总\r\n</h3>\r\n<ol style=\"color:#000000;text-indent:0px;\">\r\n	<li>\r\n		external/kernel-headers/original/asm-generic/error-base.h\r\n	</li>\r\n	<li>\r\n		external/kernel-headers/original/asm-generic/error.h\r\n	</li>\r\n	<li>\r\n		frameworks/native/include/utils/Errors.h\r\n	</li>\r\n	<li>\r\n		frameworks/av/include/media/stagefright/MediaErrors.h\r\n	</li>\r\n	<li>\r\n		frameworks/av/include/drm/drm_framework_common.h\r\n	</li>\r\n	<li>\r\n		External/chromium/net/base/net_error_list.h\r\n	</li>\r\n</ol>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.2\">\r\n	1.2. 详细介绍\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		external/kernel-headers/original/asm-generic/error-base.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				标准的Linux错误值\r\n			</li>\r\n			<li>\r\n				范围 1 ~ 34\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		external/kernel-headers/original/asm-generic/error.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				同上， 范围 35 ~ 131\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		frameworks/native/include/utils/Errors.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				OK, NO_ERROR: 0\r\n			</li>\r\n			<li>\r\n				其余的错误值，基本是以负基本Linux错误值的原则定义的\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		frameworks/av/include/media/stagefright/MediaErrors.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MediaErrors: -1000 ~ -1014\r\n			</li>\r\n			<li>\r\n				DRM\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						-2000 ~ -2007\r\n					</li>\r\n					<li>\r\n						DRM_VENDOR: -2500 ~ -2999\r\n					</li>\r\n					<li>\r\n						DRM_WV_VENDOR: 同上\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		frameworks/av/include/drm/drm_framework_common.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				同上的DRM部分，需要与它同步更新\r\n			</li>\r\n			<li>\r\n				-2000 ~ -2007\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		External/chromium/net/base/net_error_list.h\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				HTTP连接时，出错的错误值。\r\n			</li>\r\n			<li>\r\n				ChromiumHTTPDataSource类中就用到了\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 基础类库\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		Native层通用类库\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				代码位置\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						frameworks/native/include/utils/\r\n					</li>\r\n					<li>\r\n						frameworks/native/libs/utils/\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				详细介绍\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						RefBase, Looper, Thread, Mutex, Condation, RWLock,\r\n					</li>\r\n					<li>\r\n						Debug, Log, Trace,\r\n					</li>\r\n					<li>\r\n						List, Vector, KeyVector, StoredVector, PropertyMap, String8, String16, StringArray,\r\n					</li>\r\n					<li>\r\n						ShareBufer, BitSet, BlobCache, Singleton, Unicode,\r\n					</li>\r\n					<li>\r\n						ZipFile\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MultiMedia层通用类库\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				代码位置\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						frameworks/av/include/media/stagefright/foundation/\r\n					</li>\r\n					<li>\r\n						frameworks/av/media/stagefght/foundation/\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				详细介绍\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						AHandler, ALooper, AMessage, ABuffer\r\n					</li>\r\n					<li>\r\n						AString: 仿标准库中的std::string， 很好用\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. 错误值\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	1.1. 文件汇总\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	external/kernel-headers/original/asm-generic/error-base.h\r\n</p>\r\n<p>\r\n	external/kernel-headers/original/asm-generic/error.h\r\n</p>\r\n<p>\r\n	frameworks/native/include/utils/Errors.h\r\n</p>\r\n<p>\r\n	frameworks/av/include/media/stagefright/MediaErrors.h\r\n</p>\r\n<p>\r\n	frameworks/av/include/drm/drm_framework_common.h\r\n</p>\r\n<p>\r\n	External/chromium/net/base/net_error_list.h\r\n</p>\r\n<p>\r\n	1.2. 详细介绍\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	external/kernel-headers/original/asm-generic/error-base.h\r\n</p>\r\n<p>\r\n	标准的Linux错误值\r\n</p>\r\n<p>\r\n	范围 1 ~ 34\r\n</p>\r\n<p>\r\n	external/kernel-headers/original/asm-generic/error.h\r\n</p>\r\n<p>\r\n	同上， 范围 35 ~ 131\r\n</p>\r\n<p>\r\n	frameworks/native/include/utils/Errors.h\r\n</p>\r\n<p>\r\n	OK, NO_ERROR: 0\r\n</p>','','2','1','blog','5','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('14','Android中使用第三方库','1373374811','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 两个编译宏\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		如果在编译Android之前已经有编译好的库或者配置文件时，如何加入到Android中呢？\r\n	</li>\r\n	<li>\r\n		Android提供了Prebuilt编译方法，两个文件prebuilt.mk和multi_prebuilt.mk，对应的方法宏是BUILD_PREBUILT和 BUILD_MULTI_PREBUILT。\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				prebuilt.mk就是prebuilt的具体实现，它是针对独立一个文件的操作\r\n			</li>\r\n			<li>\r\n				multi_prebuilt.mk是针对多个文件的，它对多个文件进行判断，然后调用prebuilt对独立一个文件进行处理。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		如果直接用prebuilt.mk的话还是比较麻烦的，得仔细看好需要的宏，\r\n	</li>\r\n	<li>\r\n		如果使用multi_prebuilt.mk会更方便些，很多它都帮忙处理了。\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 示例\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		示例1\r\n<pre>## prebuilt etc\r\n#include $(CLEAR_VARS)\r\n#LOCAL_MODULE := \r\n#LOCAL_MODULE_TAGS := eng\r\n#LOCAL_MODULE_CLASS :=\r\n\r\n#LOCAL_MODULE_PATH := \r\n#LOCAL_SRC_FILES := \r\n#include $(BUILD_MULTI_PREBUILT)\r\n\r\n## prebuilt so/a\r\n\r\n\r\ninclude $(CLEAR_VARS)\r\nLOCAL_PREBUILT_LIBS := *.so/*.a \r\ninclude $(BUILD_MULTI_PREBUILT)\r\n\r\n\r\n\r\n更容易的方式是：\r\n\r\n$(call add-prebuilt-files, ETC, pv_player.cfg)\r\n\r\n它会将pv_player.cfg copy to system/etc下，还可以设定类型：\r\n\r\nETC,APPS,EXECUTABLES,SHARED_LIBRARIES,STATIC_LIBRARIES\r\n \r\n\r\nadd-prebuilt-files的定义是在build/core/definitions.mk下\r\n\r\n</pre>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		示例2\r\n<pre>LOCAL_PATH:= $(call my-dir)\r\n\r\ninclude $(CLEAR_VARS) \r\nLOCAL_MODULE_TAGS := optional\r\nLOCAL_PREBUILT_LIBS := libmovextractor.so\r\ninclude $(BUILD_MULTI_PREBUILT)\r\n</pre>\r\n	</li>\r\n</ul>','<p>\r\n	1. 两个编译宏\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	如果在编译Android之前已经有编译好的库或者配置文件时，如何加入到Android中呢？\r\n</p>\r\n<p>\r\n	Android提供了Prebuilt编译方法，两个文件prebuilt.mk和multi_prebuilt.mk，对应的方法宏是BUILD_PREBUILT和 BUILD_MULTI_PREBUILT。\r\n</p>\r\n<p>\r\n	prebuilt.mk就是prebuilt的具体实现，它是针对独立一个文件的操作\r\n</p>\r\n<p>\r\n	multi_prebuilt.mk是针对多个文件的，它对多个文件进行判断，然后调用prebuilt对独立一个文件进行处理。\r\n</p>\r\n<p>\r\n	如果直接用prebuilt.mk的话还是比较麻烦的，得仔细看好需要的宏，\r\n</p>\r\n<p>\r\n	如果使用multi_prebuilt.mk会更方便些，很多它都帮忙处理了。\r\n</p>\r\n<p>\r\n	2. 示例\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	示例1\r\n</p>\r\n<p>\r\n	## prebuilt etc\r\n</p>\r\n<p>\r\n	#include $(CLEAR_VARS)\r\n</p>\r\n<p>\r\n	#LOCAL_MODULE :=\r\n</p>\r\n<p>\r\n	#LOCAL_MODULE_TAGS := eng\r\n</p>\r\n<p>\r\n	#LOCAL_MODULE_CLASS :=\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	#LOCAL_MODULE_PATH :=\r\n</p>\r\n<p>\r\n	#LOCAL_SRC_FILES :=\r\n</p>\r\n<p>\r\n	#include $(BUILD_MULTI_PREBUILT)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	## prebuilt so/a\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','','2','1','blog','9','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('15','Android4.2的多用户管理中关于SD卡的实现改动','1373374842','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 问题\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		Android4.2中,通过类得到的SD卡路径类似 /storage/emulated/0 在adb shell中看不到,也不能访问.\r\n	</li>\r\n	<li>\r\n		MediaServer不能访问这样的路径.　/storage/emulated/0/\r\n	</li>\r\n	<li>\r\n		libstagefright中原先可以正常读写的SD卡路径,现在由于以上原因不能用了.\r\n	</li>\r\n	<li>\r\n		另外:　还有一个权限问题,本文不进行讨论,但它是现实存在的,由于它的存在,导致即使程序中写死实际的挂载点,它也会提示没有权限.\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. Android4.2中对SD卡Mount的实现\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. 在init.rc中创建挂载点路径,及定义环境变量\r\n</h3>\r\n<pre>mkdir /mnt/shell/emulated 0700 shell shell\r\nmkdir /storage/emulated 0555 root root\r\n \r\nexport EXTERNAL_STORAGE /storage/emulated/legacy\r\nexport EMULATED_STORAGE_SOURCE /mnt/shell/emulated\r\nexport EMULATED_STORAGE_TARGET /storage/emulated\r\n \r\n# Support legacy paths\r\nsymlink /storage/emulated/legacy /sdcard\r\nsymlink /storage/emulated/legacy /mnt/sdcard\r\nsymlink /storage/emulated/legacy /storage/sdcard0\r\nsymlink /mnt/shell/emulated/0 /storage/emulated/legacy\r\n</pre>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		其中创建的两个如下目录\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				/mnt/shell/emulated/　是实际要挂载sdcard的目录\r\n			</li>\r\n			<li>\r\n				/storage/emulated/ 是每个用户为它们自己挂载sdcard的目录.\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		SD卡实际挂载到的是 /mnt/shell/emulated/0, 其它的 /storage/emulated/legacy, /sdcard/, /mnt/sdcard/, /storage/emulated/legacy都是它的链接.\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. 进程内的不共享的挂载点\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		linux 内核命名空间,　在Linux 2.6之后引入了一个新的技术 unshare, 它可以使某个应用程序创建的挂载点等不共享,只有自己可见.\r\n	</li>\r\n	<li>\r\n		dalvik_system_Zygote.cpp中的mountEmulatedStorage()函数.　会在Zygote创建一个新的java进程时运行,　先应用 unshare , 然后再以 MS_BIND参数把 /mnt/shell/emulated/0 再挂载到 /storage/emulated/0 下.　　 (dalvik/vm/native)\r\n	</li>\r\n	<li>\r\n		其中的0是用户ID, 计算方法是 UID/100000, 代码在 system/core/libcutils/multiuser.c中.　　所以在这里的多用户,即是给每个用户一个UID段,　0 即为主用户.　新建的用户往后排. 它们拥有各自的　UID 段.\r\n	</li>\r\n	<li>\r\n		在Environment中通过一样的方法计算得到　external storage路径,　即 /storeage/emulated/0. (/frameworks/base/core/java/android/os)\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 多用户访问SD卡实现模式\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		每个用户拥有各自的应用程序,　第二个用户想安装想同的应用时,　系统会进行模拟安装 (来源自网上介绍文章)\r\n	</li>\r\n	<li>\r\n		在应用程序创建时,会创建一个它自己能访问的SD卡挂载点 /storeage/emulated/[userid].\r\n	</li>\r\n	<li>\r\n		Mediaserver等不是通过Zygote创建的native程序,　不会创建 /storage/emulated/* 挂载点,所以就不能直接访问应用程序传下来的SD路径.\r\n	</li>\r\n	<li>\r\n		adb shell 也不是通过 Zygote 来创建的,　也没有此挂载点,　所以不能访问 /storage/emulated/*\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\r\n	4. 遗留问题\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		应用程序创建的 /storage/emulated/0 路径(空路径,未挂载的目录)　为什么通过 adb shell 看不到呢, 通过什么手段隐藏的?\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.5\">\r\n	5. 最终答案\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		在这里将要解答前面不知道的两个问题\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				为什么MediaServer会没有读写 /storage/emulated/legacy/的权限呢?\r\n			</li>\r\n			<li>\r\n				为什么通过adb shell看不到 /storage/emulated/0 这个目录呢,即使它没有挂载也应该有一个空目录啊?\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		答案\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				文件 android4.2/dalvik/vm/Init.cpp 中的　initZygote()　函数\r\n<pre>static bool initZygote()\r\n{\r\n    /* zygote goes into its own process group */\r\n    setpgid(0,0);\r\n\r\n    // See storage config details at http://source.android.com/tech/storage/\r\n    // Create private mount namespace shared by all children\r\n    if (unshare(CLONE_NEWNS) == -1) {\r\n        SLOGE(\"Failed to unshare(): %s\", strerror(errno));\r\n        return -1;\r\n    }\r\n\r\n    // Mark rootfs as being a slave so that changes from default\r\n    // namespace only flow into our children.\r\n    if (mount(\"rootfs\", \"/\", NULL, (MS_SLAVE | MS_REC), NULL) == -1) {\r\n        SLOGE(\"Failed to mount() rootfs as MS_SLAVE: %s\", strerror(errno));\r\n        return -1;\r\n    }\r\n\r\n    // Create a staging tmpfs that is shared by our children; they will\r\n    // bind mount storage into their respective private namespaces, which\r\n    // are isolated from each other.\r\n    const char* target_base = getenv(\"EMULATED_STORAGE_TARGET\");\r\n    if (target_base != NULL) {\r\n        if (mount(\"tmpfs\", target_base, \"tmpfs\", MS_NOSUID | MS_NODEV,\r\n                \"uid=0,gid=1028,mode=0050\") == -1) {\r\n            SLOGE(\"Failed to mount tmpfs to %s: %s\", target_base, strerror(errno));\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n</pre>\r\n			</li>\r\n			<li>\r\n				文件android4.2/dalvik/vm/native/dalvik_system_Zygote.cpp的 mountEmulatedStorage(uid_t uid, u4 mountMode)函数,上边已经说了,这里就不再说了.\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		在上述两个地方主要做了三件事\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				先调用了一个 unsahre(), 使本进程的mount点不与其它的进程共享.\r\n			</li>\r\n			<li>\r\n				再对目录 /storage/emulated/ 做了一个 tmpfs 的挂载. 请参考<a href=\"http://zzqhost.com/Linux系统_学习笔记_tmpfs.html\">tmpfs是什么</a>\r\n			</li>\r\n			<li>\r\n				然后又以参数MS_BIND调用了mount, 把 /mnt/shell/emulated/0 又挂载到了 /storage/emulated/0/下.\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		释疑\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				/mnt/shell/目录的权限是 700, 用户是shell, 一般的进程都不可能是这个用户,所以一般的进程都没有权限对它进行读写.\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.6\">\r\n	6. 参考链接\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		<a href=\"http://blog.csdn.net/stevenliyong/article/details/5343085\">http://blog.csdn.net/stevenliyong/article/details/5343085</a>\r\n	</li>\r\n</ul>','<p>\r\n	1. 问题\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	Android4.2中,通过类得到的SD卡路径类似 /storage/emulated/0 在adb shell中看不到,也不能访问.\r\n</p>\r\n<p>\r\n	MediaServer不能访问这样的路径.　/storage/emulated/0/\r\n</p>\r\n<p>\r\n	libstagefright中原先可以正常读写的SD卡路径,现在由于以上原因不能用了.\r\n</p>\r\n<p>\r\n	另外:　还有一个权限问题,本文不进行讨论,但它是现实存在的,由于它的存在,导致即使程序中写死实际的挂载点,它也会提示没有权限.\r\n</p>\r\n<p>\r\n	2. Android4.2中对SD卡Mount的实现\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2.1. 在init.rc中创建挂载点路径,及定义环境变量\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	mkdir /mnt/shell/emulated 0700 shell shell\r\n</p>\r\n<p>\r\n	mkdir /storage/emulated 0555 root root\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	export EXTERNAL_STORAGE /storage/emulated/legacy\r\n</p>\r\n<p>\r\n	export EMULATED_STORAGE_SOURCE /mnt/shell/emulated\r\n</p>\r\n<p>\r\n	export EMULATED_STORAGE_TARGET /storage/emulated\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','','2','1','blog','9','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('16','QTCreater调试时提示ptrace不允许的操作','1373374864','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 问题描述\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		用QTCreater建立了一个纯C++的项目，但是在F5调试时，竟然提示ptrace不允许的操作，修改工程配置为Debug也不管用，经过网上搜索，原来还需要修改一下系统ptrace的配置。\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 解决办法\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		临时性的解决方法\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ sudo echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ sudo vi /etc/sysctl.d/10-ptrace.conf\r\n			</li>\r\n			<li>\r\n				$ kernel.yama.ptrace_scope = 0\r\n			</li>\r\n			<li>\r\n				重启电脑就好了，\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		据说在Ubuntu 11.04之后都会出现这种问题，貌似是为了安全\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. ptrace\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		那么ptrace是个什么东东啊，貌似是Linux下边调试时用到的一个东东，以后有空研究一下。\r\n	</li>\r\n</ul>','<p>\r\n	1. 问题描述\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	用QTCreater建立了一个纯C++的项目，但是在F5调试时，竟然提示ptrace不允许的操作，修改工程配置为Debug也不管用，经过网上搜索，原来还需要修改一下系统ptrace的配置。\r\n</p>\r\n<p>\r\n	2. 解决办法\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	临时性的解决方法\r\n</p>\r\n<p>\r\n	$ sudo echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope\r\n</p>\r\n<p>\r\n	这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：\r\n</p>\r\n<p>\r\n	$ sudo vi /etc/sysctl.d/10-ptrace.conf\r\n</p>\r\n<p>\r\n	$ kernel.yama.ptrace_scope = 0\r\n</p>\r\n<p>\r\n	重启电脑就好了，\r\n</p>\r\n<p>\r\n	据说在Ubuntu 11.04之后都会出现这种问题，貌似是为了安全\r\n</p>\r\n<p>\r\n	3. ptrace\r\n</p>','','2','3','blog','3','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('17','ubuntu安装极点五笔输入法','1373374891','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 说明\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		安装的是极点输入法\r\n	</li>\r\n	<li>\r\n		是ibus框架下的\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 安装步骤\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		下载附件文件vissible-ibus.tar.gz\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				免费下载地址在 <a href=\"http://linux.linuxidc.com/\">http://linux.linuxidc.com/</a>\r\n			</li>\r\n			<li>\r\n				用户名与密码都是 www.linuxidc.com\r\n			</li>\r\n			<li>\r\n				具体下载目录在 /pub/2011/10/23/Ubuntu 11.10安装极点五笔/\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		右键点下载好的\"vissible-ibus.tar.gz\"压缩包，然后选\"解压到此处\"即可得到\"vissible.db、vissible.gif、vissible.txt\"三个文件，然后将这三个文件全部移动到\"主文件夹\"目录下。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		按快捷键\"Ctrl+Alt+T\"调出终端并输入下面命令后回车：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ sudo cp vissible.db /usr/share/ibus-table/tables\r\n			</li>\r\n			<li>\r\n				$ sudo cp vissible.gif /usr/share/ibus-table/icons\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		完了之后把\"主文件夹里的三个文件删除即可。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		启用\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在任务栏右键点那个键盘小图标，在下拉菜单选\"重新重启\"（这个重新启动并不是重并报启动系统，而是重新启动ibus输入法）\r\n			</li>\r\n			<li>\r\n				然后再右键点那个键盘小图标并在下拉菜单中选\"首选项\"，\r\n			</li>\r\n			<li>\r\n				然后在弹出的窗口中点击\"输入法\"选项卡，\r\n			</li>\r\n			<li>\r\n				接着点\"选择输入法\"，\r\n			</li>\r\n			<li>\r\n				然后添加极点五笔就可以了。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. 说明\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	安装的是极点输入法\r\n</p>\r\n<p>\r\n	是ibus框架下的\r\n</p>\r\n<p>\r\n	2. 安装步骤\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	下载附件文件vissible-ibus.tar.gz\r\n</p>\r\n<p>\r\n	免费下载地址在 http://linux.linuxidc.com/\r\n</p>\r\n<p>\r\n	用户名与密码都是 www.linuxidc.com\r\n</p>\r\n<p>\r\n	具体下载目录在 /pub/2011/10/23/Ubuntu 11.10安装极点五笔/\r\n</p>\r\n<p>\r\n	右键点下载好的\"vissible-ibus.tar.gz\"压缩包，然后选\"解压到此处\"即可得到\"vissible.db、vissible.gif、vissible.txt\"三个文件，然后将这三个文件全部移动到\"主文件夹\"目录下。\r\n</p>\r\n<p>\r\n	按快捷键\"Ctrl+Alt+T\"调出终端并输入下面命令后回车：\r\n</p>\r\n<p>\r\n	$ sudo cp vissible.db /usr/share/ibus-table/tables\r\n</p>\r\n<p>\r\n	$ sudo cp vissible.gif /usr/share/ibus-table/icons\r\n</p>','','2','4','blog','3','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('18','linux mint下使用磁盘实用工具','1373374915','\n<ul style=\"MARGIN-TOP: 1em; PADDING-LEFT: 0.5em; MARGIN-BOTTOM: 1em; WORD-SPACING: 0px; FONT: 15px/20px Tahoma, Geneva, sans-serif; MARGIN-LEFT: 2em; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; webkit-text-stroke-width: 0px\">\n<li style=\"MARGIN: 0.3em auto\">磁盘实用工具是ubuntu下一个非常好用的磁盘管理及查看工具,但是在Linux mint上怎么找也找不到,怎么回事?</li>\n<li style=\"MARGIN: 0.3em auto\">原来从Linux mint 13开始,默认没有安装它，可在\"软件管理器\"中安装gnome-disk-utility,或通过以下命令进行安装:\n<ul style=\"MARGIN-TOP: 0.5em; PADDING-LEFT: 0.5em; MARGIN-BOTTOM: 0.5em; MARGIN-LEFT: 2em\">\n<li style=\"MARGIN: 0.3em auto\">sudo apt-get install gnome-disk-utility</li>\n</ul>\n</li>\n</ul>\n','','','2','4','blog','5','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('19','ramfs,tmpfs,rootfs,initramfs和romfs','1373374947','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. ramfs\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		其实tmpfs, rootfs, initramfs都是ramfs的一种,它们或者是对它的一些特殊的应用,或者是对它某一方面能力的改进加强.\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.1\">\r\n	1.1. ramfs是什么\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		ramfs是一个非常简单的文件系统，它输出Linux的磁盘缓存机制(页缓存和目录缓存)作为一个大小动态的基于内存的文件系统。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		通常，所有的文件由Linux被缓存在内存中。页的数据从保持在周围以防再次需要的后备存储(一般被挂载的是块设备文件系统)中读取，并标记为可用(空闲)以防虚拟内存系统(Virtual Memory System)需要这些内存作为别用。类似的，在数据写回后备存储时，数据一写回文件就立即被标记为可用，但周围的缓存被保留着直至VM(虚拟机)重新分配内存。一个类似的机制(目录缓存)极大的加快了对目录的访问。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		ramfs并没有后备存储。文件写入ramfs象往常一样，来分配目录和页的缓存，但这里并没有地方可写回它们。这意味着页的数据不再标记为可用，因此当希望回收内存时，内存不能通过VM来释放。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		实现ramfs所需的代码总量是极少的，因为所有的工作由现有的Linux缓存结构来完成。实际上，你现正在挂载磁盘缓存作为一个文件系统。据此，ramfs并不是一个可通过菜单配置项来卸载的可选组件，它可节省的空间是微不足道的。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.2\">\r\n	1.2. ramfs和ramdisk\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		旧的\"内存磁盘\"机制在一个内存空间中创建一个合成块设备并使用它作为一个文件系统的后备存储。这个块设备是固定大小的以至于挂载在它上面的文件系统也是固定大小的。除创建和销毁目录外，使用一个内存磁盘并不需要从假的块设备到页缓存拷贝内存数据(和拷贝更改回退)。另外，它需要一个文件系统驱动 (如，ext2)来格式和解释这些数据。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		与ramfs相比较，这些废弃的内存(和内存总线带宽)为CPU造成了不必要的工作并污染了CPU缓存。(这里有个技巧通过使用页表单来避免这个拷贝，但是它们难以理解并且代价反而变的与拷贝一样昂贵。)更为重要的是，由于所有的文件都通过页和目录缓存进行访问，全部的工作ramfs都要执行。内存磁盘是简单且多余的，ramfs在内部更为简单。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		另一个理由是：ramdisks是半过时的，它引进的回环设备提供一个更灵活和方便的方式从文件而不是从大块的内存中来创建一个合成块设备。\r\n	</li>\r\n</ul>\r\n<p style=\"color:#000000;text-indent:0px;\">\r\n	参见losetup (8) 来获得有关细节。\r\n</p>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.3\">\r\n	1.3. tmpfs\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		ramfs的一个不利之处是你将保留写回到ramfs的数据直至你填补所有的内存，并且VM不能释放它，因为VM考虑到文件将写回后备存储(而不是交换空间)，但是ramfs并不能获得任何的后备存储。据此，只有root(或者一个受信任的用户)可允许回写到一个ramfs挂载中。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		tmpfs是从ramfs派生出的,添加了大小的限制以及回写数据到交换空间能力的特殊ramfs。普通用户可以允许回写到tmpfs挂载中。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		使用tmpfs\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ mount tmpfs /dev/shm -t tmpfs -o size=32m\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.4\">\r\n	1.4. rootfs\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		rootfs是一个特定的ramfs(或tmpfs，如果那被启用)的实例，它始终存在于2.6的系统。\r\n	</li>\r\n	<li>\r\n		你不能卸载rootfs，这个理由近似于你不能杀死init进程。它小巧且简单的为内核确保某些列表不能为空，而不是拥有特定的代码来检查和处理一个空列表。\r\n	</li>\r\n	<li>\r\n		大多数的系统挂载另一个文件系统到rootfs并忽略它。一个空白ramfs实例的空间总量占用是极小的。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.5\">\r\n	1.5. initramfs\r\n</h3>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.1\">\r\n	1.5.1. initramfs是什么\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		所有的2.6 Linux内核包含了一个gzip压缩过的\"cpio\"格式存档，当内核启动时它将被提取到rootfs。\r\n	</li>\r\n	<li>\r\n		在提取之后，内核检测rootfs是否包含了一个\"init\"文件，如果包含就来执行它并设置PID为1。\r\n	</li>\r\n	<li>\r\n		这个init进程将负责引导系统的其余内容，包含了要寻找和挂载的真正根设备(若有的话)。\r\n	</li>\r\n	<li>\r\n		如果rootfs在提取cpio存档以后并不包含一个init程序，内核将失败并通过旧的代码来寻找和挂载一个根分区，接着执行一些/sbin /init的变种。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.2\">\r\n	1.5.2. 与旧的initrd不同点\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		旧的initrd通常是一个独立的文件，而initramfs存档是连接到linux内核映像的。(Linux系统目录-*/usr 在构建时就是为了生成这个存档)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		旧的initrd文件是一个gzip压缩过的文件系统映像(在一些文件格式，如ext2,需要构建一个驱动到内核)，而这个新的initramfs存档是一个gzip压缩过的cpio存档(象tar一样简单，参见cpio(1) and Documentation/early-userspace/buffer-format.txt)。内核的cpio提取代码不仅极少，而且init文本和数据可以在启动过程中被丢弃。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		程序通过旧的initrd(叫做/initrd，而不是/init)运行一些设定并接着返回内核，而init程序从initramfs并不预计返回内核。(如果/init需要手工关闭并控制它，可以与一个新的根设备一起覆盖挂载 / 并执行另一个init程序。参见switch_root utility的后部分)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		当切换到另一个根设备，initrd会pivot_root并且接着卸载内存磁盘。但是initramfs是rootfs：你可以不用 pivot_root rootfs和卸载它。而是删除除rootfs之外的所有东西来释放空间(find -xdev / -exec rm \'{}\' \';\'),与新的根(cd /newmount; mount --move . /; chroot .)一起覆盖挂载rootfs,附加stdin/stdout/stderr到新的/dev/console并执行新的init。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		由于这是一个非常谨慎的进程(以及在你运行它们之前涉及到删除命令)，klibc包为你引进了一个帮助程序(utils/run_init.c)来做这些。大部分其他软件包(如，busybox)已命名在此命令\"switch_root\"中。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.3\">\r\n	1.5.3. 提供 initramfs\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		v2.6 内核构建进程总是创建一个gzip压缩过的cpio格式的initramfs存档并连接它到生成的内核二进制文件。默认的，这些存储是空的(在x86上占用134 bytes)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		配置选项CONFIG_INITRAMFS_SOURCE(存在于menuconfig的General Setup选项和usr/Kconfig中)可为initramfs存档使用特定的一个源文件，它自动合并到生成的二进制文件中。这个选项可以指定一个现有的gzip压缩的cpio存档，这个存档可以包含一个目录文件到或者是一个文本文件详述，如下面的示例:\r\n<pre>dir /dev 755 0 0\r\nnod /dev/console 644 0 0 c 5 1\r\nnod /dev/loop0 644 0 0 b 7 0\r\ndir /bin 755 1000 1000\r\nslink /bin/sh busybox 777 0 0\r\nfile /bin/busybox initramfs/busybox 755 0 0\r\ndir /proc 755 0 0\r\ndir /sys 755 0 0\r\ndir /mnt 755 0 0\r\nfile /init initramfs/init.sh 755 0 0\r\n</pre>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		在文件格式之上运行\"usr/gen_init_cpio\"(在构建内核之后)来获得一个用法文档。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		一个高级的配置文件是root访问不需要在新的存档上设置权限或者创建设备节点。(注意示例的那两个\"file\"期望在linux-2.6.*目录下，在\"initramfs\"目录中找到名为\"init.sh\"和\"busybox\"的文件。参见Documentation/early- userspace/README 以获得更多细节。)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		内核并不依赖外部的cpio工具。如果你指定一个目录而不是一个配置文件，内核的构建结构将从那个目录(usr/Makefile 调用\r\n	</li>\r\n</ul>\r\n<p style=\"color:#000000;text-indent:0px;\">\r\n	scripts/gen_initramfs_list.sh)创建一个配置文件，并封装该目录来使用配置文件(通过释放它到从 usr/gen_init_cpio.c 创建的 usr/gen_init_cpio)。在内核构建时cpio创建的代码是完全独立的，在内核开启时提取器也是(完全)独立的。\r\n</p>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		你唯一可能需要为创建或提取你自己的cpio文件以提供给内核构建(而不是一个配置文件或目录)而安装外部的cpio工具。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		以下的命令行可提取一个cpio映像(不管是通过以上脚本或是通过内核构建成的)回退到它的组成文件：\r\n<pre>    cpio -i -d -H newc -F initramfs_data.cpio --no-absolute-filenames\r\n</pre>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		以下的shell脚本可创建一个预制的cpio存档，你可以使用在上述的配置文件中：\r\n<pre>#!/bin/sh\r\n\r\n# Copyright 2006 Rob Landley <rob@landley.net> and TimeSys Corporation.\r\n# Licensed under GPL version 2\r\n\r\nif [ $# -ne 2 ]\r\nthen\r\n    echo \"usage: mkinitramfs directory imagename.cpio.gz\"\r\n    exit 1\r\nfi\r\n\r\nif [ -d \"$1\" ]\r\nthen\r\n    echo \"creating $2 from $1\"\r\n    (cd \"$1\"; find . | cpio -o -H newc | gzip) &gt; \"$2\"\r\nelse\r\n    echo \"First argument must be a directory\"\r\n    exit 1\r\nfi\r\n</rob@landley.net></pre>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		注意：如果你是按照cpio的man页做的，那么它包含的一些不良建议将会破坏你的initramfs存档。它说\"生成文件名列表的一个典型方式是使用 find命令，你应该提供-depth选项来搜索\"。而在创建initramfs.cpio.gz映像时不要这么做，因为它并不可行。Linux内核的 cpio提取器不会在一个不存在的目录中创建文件，因此目录项必须在文件被提取到该目录之前被提取。以上脚本保证了它们的顺序正确性。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.4\">\r\n	1.5.4. 外部initramfs映像\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		如果内核有启用initrd支持，一个外部的cpio.gz存档也可替换一个2.6 内核的initrd。既然这样，内核将自动检测文件类型(initramfs, 而不是initrd)并在尝试运行/init前，提取外部的cpio存档到rootfs。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		initramfs有内存效率的优势(没有内存磁盘块设备)，而initrd可单独封装(如果你有非GPL许可协议的代码，而你想从initramfs运行，这还是不错的。不要与GPL许可的二进制的Linux内核混为一谈)。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		外部initramfs映像也可以用来补充内核内建的initramfs映像。外部存档文件将覆盖与内建initramfs存档中任意不一致的文件。一些发行商也偏爱定制一个单一内核映像和特定initramfs映像，而不用重编译。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.5\">\r\n	1.5.5. initramfs的内容\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		一个initramfs存档是一个完整独立的Linux根文件系统。如果你还不能理解共享库、设备和路径，你需要获得一个小的根文件系统来启动和运行，这里有一些参考资料：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://www.tldp.org/HOWTO/Bootdisk-HOWTO/\">http://www.tldp.org/HOWTO/Bootdisk-HOWTO/</a>\r\n			</li>\r\n			<li>\r\n				<a href=\"http://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html\">http://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html</a>\r\n			</li>\r\n			<li>\r\n				<a href=\"http://www.linuxfromscratch.org/lfs/view/stable/\">http://www.linuxfromscratch.org/lfs/view/stable/</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		软件包\"klibc\"(<a href=\"http://www.kernel.org/pub/linux/libs/klibc)被设计为一个极小的C库来静态连接早期的用户空间代码，以及一些相关的工具。它是BSD授权。\">http://www.kernel.org/pub/linux/libs/klibc)被设计为一个极小的C库来静态连接早期的用户空间代码，以及一些相关的工具。它是BSD授权。</a>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		我使用uClibc (<a href=\"http://www.uclibc.xn--org)busybox-u59v/\">http://www.uclibc.org)和busybox</a> (<a href=\"http://www.busybox.net).xn--lgplgpl-ku4k67wukan7tkp4c7ghx0dqv5s.xn--(initramfsbusybox-qs50a2w47jvpvz2e7x2ayj6mf1saonzq86folr6gz/\">http://www.busybox.net)。这些分别是LGPL和GPL授权。(一个独立的initramfs软件包被计划在busybox</a> 1.3 release。)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		从理论上说你可以使用glibc，但是对于小型嵌入式系统象这样使用并适合。(一个\"hello world\"程序静态连接glibc将近400k。用uClibc的话它是7k。还要注意，glibc dlopens libnss作为名称查找，即使是使用静态连接。)\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		一个好的开头是获得initramfs来运行一个静态连接的\"hello world\"程序作为init，并在一个类似qemu(www.qemu.org)的仿真器或用户模式的Linux中测试它，象这样：\r\n<pre>cat &gt; hello.c &lt;&lt; EOF\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    printf(\"Hello world!/n\");\r\n    sleep(999999999);\r\n}\r\nEOF\r\ngcc -static hello.c -o init\r\necho init | cpio -o -H newc | gzip &gt; test.cpio.gz\r\n# Testing external initramfs using the initrd loading mechanism.\r\nqemu -kernel /boot/vmlinuz -initrd test.cpio.gz /dev/zero\r\n</unistd.h></stdio.h></pre>\r\n	</li>\r\n	<li>\r\n		当调试一个普通根文件系统时，能够用\"init=/bin/sh\"来启动将是不错的。与initramfs等价的是\"rdinit=/bin/sh\"，而且它很有用。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.6\">\r\n	1.5.6. 为什么是cpio而不是tar?\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		这个决定的发布是在2001年12月。讨论浏览在这里:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1538.html\">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1538.html</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		并且催生了第二件事情(tar与cpio的比较)，浏览这里\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1587.html\">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1587.html</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		快速且直接的总结版本(这些是无法替代上述内容的阅读的)：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				cpio是一个标准。它十来岁了(从 AT&amp;T起)，并已被广泛应用在Linux上(在RPM中，Red Hat的设备驱动磁盘上)。这里有从1996年起有关它的Linux日志：\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						<a href=\"http://www.linuxjournal.com/article/1213\">http://www.linuxjournal.com/article/1213</a>\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		它并没有象tar一样流行，因为传统的cpio命令行工具要求使用极可怕的命令行。同时没有其他有关存档格式的方式，并有可选的工具。如:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://freshmeat.net/projects/afio/\">http://freshmeat.net/projects/afio/</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		cpio存档格式是由内核选择的，它比(许多国家的)任意的tar存档格式都简单且干净(并极容易来创建和解析)。完整的initramfs存档格式说明在buffer-format.txt，创建在usr/gen_init_cpio.c，并提取在init/initramfs.c。所有三个可阅读的文本一起不到26k。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		GNU项目使用tar标准似乎是与Windows使用zip的标准相关。Linux并不是它们中任一一个，并自由的作出了自己的技术决策。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		由于这是一个内核的内部格式，它可以很容易做一些更新。内核提供它自己的工具来创建和提取这个格式。使用现有的标准是可取的，但不是必要的。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		Al Viro 作出决定(引用: \"tar is ugly as hell and not going to be supported on the kernel side\"):\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1540.html\">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1540.html</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		解释它的理由：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1550.html\">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1550.html</a>\r\n			</li>\r\n			<li>\r\n				<a href=\"http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1638.html\">http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1638.html</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		最重要的是，设计和实现initramfs的代码。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.1.5.7\">\r\n	1.5.7. 发展的方向\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		当前(2.6.16), initramfs总被编译进，但并没总被使用。内核做到回退到原来的启动代码只需initramfs中不包含一个/init程序。回退\r\n	</li>\r\n</ul>\r\n<p style=\"color:#000000;text-indent:0px;\">\r\n	是原来的代码，以此确保一个平滑的过渡并允许尽早的开启功能逐步移动到\"前期用户空间\"(即initramfs)。\r\n</p>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		移动到前期用户空间是必要的，因为寻找和挂载真正的根设备是复杂的。根分区可以跨多个设备。它们可在网络上进行(要求dhcp，设定一个特定MAC地址，登录到一台服务器等)。它们可用在可移动媒体，动态分配主/次号以及要求udev执行清理的持续命名的问题。它们可被压缩、加密、写时拷贝，回环挂载、异常分区等。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		这种复杂性(必将包含的策略)是在用户空间的处理的正确性。klibc和busybox/uClibc两者一起在简单的initramfs软件包中工作以组成一个内核构建。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		软件包klibc现在已被Andrew Morton\'s 2.6.17-mm 接受到树中。内核当前的提前启动代码(分区检测等)可能会迁移到默认的initramfs中，由内核构建自动创建并使用。\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. romfs\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		romfs 是只读的文件系统,本文不讨论它,由于它与ramfs写法很相近,所以在此列出它,可以参考外部链接:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				<a href=\"http://wxpjiujiang.blog.163.com/blog/static/203994030201222295944637/\">http://wxpjiujiang.blog.163.com/blog/static/203994030201222295944637/</a>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. ramfs\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	其实tmpfs, rootfs, initramfs都是ramfs的一种,它们或者是对它的一些特殊的应用,或者是对它某一方面能力的改进加强.\r\n</p>\r\n<p>\r\n	1.1. ramfs是什么\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ramfs是一个非常简单的文件系统，它输出Linux的磁盘缓存机制(页缓存和目录缓存)作为一个大小动态的基于内存的文件系统。\r\n</p>\r\n<p>\r\n	通常，所有的文件由Linux被缓存在内存中。页的数据从保持在周围以防再次需要的后备存储(一般被挂载的是块设备文件系统)中读取，并标记为可用(空闲)以防虚拟内存系统(Virtual Memory System)需要这些内存作为别用。类似的，在数据写回后备存储时，数据一写回文件就立即被标记为可用，但周围的缓存被保留着直至VM(虚拟机)重新分配内存。一个类似的机制(目录缓存)极大的加快了对目录的访问。\r\n</p>\r\n<p>\r\n	ramfs并没有后备存储。文件写入ramfs象往常一样，来分配目录和页的缓存，但这里并没有地方可写回它们。这意味着页的数据不再标记为可用，因此当希望回收内存时，内存不能通过VM来释放。\r\n</p>\r\n<p>\r\n	实现ramfs所需的代码总量是极少的，因为所有的工作由现有的Linux缓存结构来完成。实际上，你现正在挂载磁盘缓存作为一个文件系统。据此，ramfs并不是一个可通过菜单配置项来卸载的可选组件，它可节省的空间是微不足道的。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>','','2','4','blog','48','1','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('20','用U盘安装Linux系统的通用方法','1373374977','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 前言\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		本篇文章介绍通过在U盘上安装Grub2,并手动在Grub2中启动Linux发行版iso的方法来安装Linux系统.\r\n	</li>\r\n	<li>\r\n		采用的发行版是Linux-mint 14.1 64 bit.\r\n	</li>\r\n	<li>\r\n		本人的笔记本是联想Y450,直接通过Universal-USB-Installer制作的U盘,启动时根本进不了启动菜单,花屏了.\r\n	</li>\r\n	<li>\r\n		所以寻找到了这种方法,　主要参考了 <a href=\"http://www.cnblogs.com/hiflex/archive/2012/07/22/flex.html\">http://www.cnblogs.com/hiflex/archive/2012/07/22/flex.html</a> 并实际实验,修改了一些错误及过时的命令.\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 步骤\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. 制作安装U盘\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		安装Grub2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				可以参考我的博文:　<a href=\"http://blog.csdn.net/zzqhost/article/details/5935317\">http://blog.csdn.net/zzqhost/article/details/5935317</a>\r\n			</li>\r\n			<li>\r\n				主要命令如下:\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						$ sudo grub-install --root-directory=/media/zzq/*** /dev/sdb\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		COPY必要的文件到U盘上\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				把iso文件拷贝到U盘的根目录下，\r\n			</li>\r\n			<li>\r\n				从iso文件的casper目录下解压出vmliunz和initrd.lz两个文件，把这两个文件也放在U盘的根目录下。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. 安装Linuxmint\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		以此U盘重启,进入Grub2\r\n	</li>\r\n	<li>\r\n		$ linux (hd0,1)/vmlinuz boot=casper iso-scan/filename=(hd0,1)/linuxmint-14.1-mate-dvd-64bit.iso ro quiet\r\n	</li>\r\n	<li>\r\n		$ initrd (hd0,1)/initrd.lz\r\n	</li>\r\n	<li>\r\n		$ boot\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. Grub2中的一些命令\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		参考我的博文<a href=\"http://blog.csdn.net/zzqhost/article/details/5978826\">http://blog.csdn.net/zzqhost/article/details/5978826</a>\r\n	</li>\r\n	<li>\r\n		硬盘的表示法可以用: (hd0,1)这样的方式来表示,　如 (hd0,1)/initrd.lz 表示的就是某个分区根目录下的 initrd.lz文件.\r\n	</li>\r\n	<li>\r\n		hd0,hd1等是硬盘的编号,从0开始,在我这里, hd0是U盘,　hd1是实际的U盘.\r\n	</li>\r\n	<li>\r\n		(hd0,1)中后边的1表示的是分区编号,从1开始.与Linux操作系统中的相同.　1,2,3,4是主分区,从5开始表示逻辑分区\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\r\n	4. 安装前说明\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		这篇文章中的方法在公司的机器中实践通过.　等周末回家在我的小Y上试一下,看看有没有作用?\r\n	</li>\r\n	<li>\r\n		这个方法可以跳过用Universal-USB-Installer等工具制作的启动盘的启动菜单,直接启动LiveCD.\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.5\">\r\n	5. 后记\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		用此方法在我的Y450上已经成功安装linux mint 14, 看来linux mint live CD的安装盘中用的Grub中的功能太高级了,在我的电脑上出不来安装菜单.但用此方法成功搞定\r\n	</li>\r\n	<li>\r\n		安装过程中碰到了一个错误: line 46 can\'t open /dev/sr0： No Medium found , 已经解决,如下:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				网上有人说这是硬盘模式不正确,需要在BIOS中修改一下,把AHCI改为IDE.　但我碰到的这次不是因为这个原因,因为我的硬盘本来就是IDE.\r\n			</li>\r\n			<li>\r\n				老老实实的按照后边的提示,在Windows下把U盘格式化了一遍,选择格式为Fat32, 钩选上全部格式化,完了之后再重新按照以上的方法制作安装盘. 成功!!\r\n			</li>\r\n			<li>\r\n				可能的原因: U盘格式不正确,　U盘上的碎片太多了.\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. 前言\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	本篇文章介绍通过在U盘上安装Grub2,并手动在Grub2中启动Linux发行版iso的方法来安装Linux系统.\r\n</p>\r\n<p>\r\n	采用的发行版是Linux-mint 14.1 64 bit.\r\n</p>\r\n<p>\r\n	本人的笔记本是联想Y450,直接通过Universal-USB-Installer制作的U盘,启动时根本进不了启动菜单,花屏了.\r\n</p>\r\n<p>\r\n	所以寻找到了这种方法,　主要参考了 http://www.cnblogs.com/hiflex/archive/2012/07/22/flex.html 并实际实验,修改了一些错误及过时的命令.\r\n</p>\r\n<p>\r\n	2. 步骤\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2.1. 制作安装U盘\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	安装Grub2\r\n</p>\r\n<p>\r\n	可以参考我的博文:　http://blog.csdn.net/zzqhost/article/details/5935317\r\n</p>\r\n<p>\r\n	主要命令如下:\r\n</p>\r\n<p>\r\n	$ sudo grub-install --root-directory=/media/zzq/*** /dev/sdb\r\n</p>\r\n<p>\r\n	COPY必要的文件到U盘上\r\n</p>\r\n<p>\r\n	把iso文件拷贝到U盘的根目录下，\r\n</p>\r\n<p>\r\n	从iso文件的casper目录下解压出vmliunz和initrd.lz两个文件，把这两个文件也放在U盘的根目录下。\r\n</p>\r\n<p>\r\n	2.2. 安装Linuxmint\r\n</p>','','2','4','blog','3','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('21','关闭定时updatedb,解决开机硬盘狂转问题','1373375001','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 现象\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		有时刚启动完就会发现硬盘灯总在不停的闪烁。其实这是因为后台有程序在运行。\r\n	</li>\r\n	<li>\r\n		运行命令\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$top\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		刷新几次就可以知道系统中都有哪此吃资源的大户了。记下它们的名字再做处理。按\"q\"键退出top程序。\r\n	</li>\r\n	<li>\r\n		在我机器上引起硬盘狂转的是 updatedb.mlocate, 为硬盘文件建立索引，以便于使用locate命令能找到文件。\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 解决\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		由于我几乎从来不用locate命令，我决定降低updatedb的频率。\r\n	</li>\r\n	<li>\r\n		通过下面的查找得知,ubuntu中updatedb是由mlocate来定时启动的。\r\n	</li>\r\n	<li>\r\n		在/etc搜索updatedb，在/etc/cron.daily下找到mlocate\r\n	</li>\r\n	<li>\r\n		只要把这个脚本删了或移到其它位置就可以了。\r\n	</li>\r\n	<li>\r\n		我是将它变成每月运行一次。\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ sudo mv /etc/cron.daily/mlocate /etc/cron.monthly/\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		问题解决啦！\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 一个建议\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		系统变慢时，用top查看最占资源的程序。\r\n	</li>\r\n</ul>','<p>\r\n	1. 现象\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	有时刚启动完就会发现硬盘灯总在不停的闪烁。其实这是因为后台有程序在运行。\r\n</p>\r\n<p>\r\n	运行命令\r\n</p>\r\n<p>\r\n	$top\r\n</p>\r\n<p>\r\n	刷新几次就可以知道系统中都有哪此吃资源的大户了。记下它们的名字再做处理。按\"q\"键退出top程序。\r\n</p>\r\n<p>\r\n	在我机器上引起硬盘狂转的是 updatedb.mlocate, 为硬盘文件建立索引，以便于使用locate命令能找到文件。\r\n</p>\r\n<p>\r\n	2. 解决\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	由于我几乎从来不用locate命令，我决定降低updatedb的频率。\r\n</p>\r\n<p>\r\n	通过下面的查找得知,ubuntu中updatedb是由mlocate来定时启动的。\r\n</p>\r\n<p>\r\n	在/etc搜索updatedb，在/etc/cron.daily下找到mlocate\r\n</p>\r\n<p>\r\n	只要把这个脚本删了或移到其它位置就可以了。\r\n</p>\r\n<p>\r\n	我是将它变成每月运行一次。\r\n</p>\r\n<p>\r\n	$ sudo mv /etc/cron.daily/mlocate /etc/cron.monthly/\r\n</p>\r\n<p>\r\n	问题解决啦！\r\n</p>','','2','4','blog','4','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('22','功能强大的命令dd','1373375039','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. dd 的主要选项\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.1\">\r\n	1.1. 说明\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		指定数字的地方若以下列字符结尾, 则乘以相应的数字:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				b=512, c=1, k=1024, w=2, xm=number m\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.2\">\r\n	1.2. 选项\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		if=file\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				输入文件名，缺省为标准输入。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		of=file\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				输出文件名，缺省为标准输出。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		ibs=bytes\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				一次读入 bytes 个字节(即一个块大小为 bytes 个字节)。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		obs=bytes\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				一次写 bytes 个字节(即一个块大小为 bytes 个字节)。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		bs=bytes\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		cbs=bytes\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				一次转换 bytes 个字节，即转换缓冲区大小。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		skip=blocks\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				从输入文件开头跳过 blocks 个块后再开始复制。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		seek=blocks\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				从输出文件开头跳过 blocks 个块后再开始复制。(通常只有当输出文件是磁盘或磁带时才有效)。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		count=blocks\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		conv=conversion[,conversion...]\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				用指定的参数转换文件。\r\n			</li>\r\n			<li>\r\n				转换参数:\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						ascii 转换 EBCDIC 为 ASCII。\r\n					</li>\r\n					<li>\r\n						ebcdic 转换 ASCII 为 EBCDIC。\r\n					</li>\r\n					<li>\r\n						ibm 转换 ASCII 为 alternate EBCDIC.\r\n					</li>\r\n					<li>\r\n						block 把每一行转换为长度为 cbs 的记录，不足部分用空格填充。\r\n					</li>\r\n					<li>\r\n						unblock 使每一行的长度都为 cbs ，不足部分用空格填充。\r\n					</li>\r\n					<li>\r\n						lcase 把大写字符转换为小写字符。\r\n					</li>\r\n					<li>\r\n						ucase 把小写字符转换为大写字符。\r\n					</li>\r\n					<li>\r\n						swab 交换输入的每对字节。\r\n					</li>\r\n					<li>\r\n						noerror 出错时不停止。\r\n					</li>\r\n					<li>\r\n						notrunc 不截短输出文件。\r\n					</li>\r\n					<li>\r\n						sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐。\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		总结, 通过以上的说明可以看到,参数主要分为以下几个部分:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				指定输入和输出: if, of\r\n			</li>\r\n			<li>\r\n				指定一个块的大小,　可以用 ibs, obs, bs, cbs这几个参数\r\n			</li>\r\n			<li>\r\n				指定动作及操作的块数: skip, seek, count, 具体的大小就是上一个参数指定的块大小和本参数指定的块数的乘积.\r\n			</li>\r\n			<li>\r\n				此条与上一条并列:指定转换几转换参数 conv\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 实例分析\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. 数据备份与恢复\r\n</h3>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.1\">\r\n	2.1.1. 整盘数据备份与恢复\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		备份\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				dd if=/dev/hdx of=/dev/hdy\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						将本地的/dev/hdx整盘备份到/dev/hdy\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				dd if=/dev/hdx of=/path/to/image\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						将/dev/hdx全盘数据备份到指定路径的image文件\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				dd if=/dev/hdx | gzip &gt;/path/to/image.gz\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		恢复\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				dd if=/path/to/image of=/dev/hdx\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						将备份文件恢复到指定盘\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				gzip -dc /path/to/image.gz | dd of=/dev/hdx\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						将压缩的备份文件恢复到指定盘\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.2\">\r\n	2.1.2. 利用netcat远程备份\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP &gt; 1234\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在源主机上执行此命令备份/dev/hda\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		netcat -l -p 1234 | dd of=/dev/hdc bs=16065b\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在目的主机上执行此命令来接收数据并写入/dev/hdc\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		netcat -l -p 1234 | bzip2 &gt; partition.img\r\n	</li>\r\n	<li>\r\n		netcat -l -p 1234 | gzip &gt; partition.img\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				以上两条指令是目的主机指令的变化分别采用bzip2 gzip对数据进行压缩，并将备份文件保存在当前目录。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.3\">\r\n	2.1.3. 备份MBR\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		备份\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				dd if=/dev/hdx of=/path/to/image count=1 bs=512\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						备份磁盘开始的512Byte大小的MBR信息到指定文件\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		恢复\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				dd if=/path/to/image of=/dev/hdx\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						将备份的MBR信息写到磁盘开始部分\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.4\">\r\n	2.1.4. 备份软盘\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/fd0 of=disk.img count=1 bs=1440k\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				将软驱数据备份到当前目录的disk.img文件\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.5\">\r\n	2.1.5. 拷贝内存资料到硬盘\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/mem of=/root/mem.bin bs=1024\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				将内存里的数据拷贝到root目录下的mem.bin文件\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.6\">\r\n	2.1.6. 从光盘拷贝iso镜像\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/cdrom of=/root/cd.iso\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				拷贝光盘数据到root文件夹下，并保存为cd.iso文件\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. 增加Swap分区文件大小\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/zero of=/swapfile bs=1024 count=262144\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				创建一个足够大的文件（此处为256M）\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		mkswap /swapfile\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				把这个文件变成swap文件\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		swapon /swapfile\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				启用这个swap文件\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		/swapfile swap swap defaults 0 0\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.3\">\r\n	2.3. 销毁磁盘数据\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/urandom of=/dev/hda1\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。执行此操作以后，/dev/hda1将无法挂载，创建和拷贝操作无法执行。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.4\">\r\n	2.4. 磁盘管理\r\n</h3>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.4.1\">\r\n	2.4.1. 得到最恰当的block size\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file\r\n	</li>\r\n	<li>\r\n		dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file\r\n	</li>\r\n	<li>\r\n		dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file\r\n	</li>\r\n	<li>\r\n		dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				通过比较dd指令输出中所显示的命令执行时间，即可确定系统最佳的block size大小\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.4.2\">\r\n	2.4.2. 测试硬盘读写速度\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/root/1Gb.file bs=64k | dd of=/dev/null\r\n	</li>\r\n	<li>\r\n		dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				通过上两个命令输出的执行时间，可以计算出测试硬盘的读／写速度\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.4.3\">\r\n	2.4.3. 修复硬盘\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		dd if=/dev/sda of=/dev/sda\r\n	</li>\r\n	<li>\r\n		当硬盘较长时间（比如1，2年）放置不使用后，磁盘上会产生magnetic flux point。当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。且这个过程是安全，高效的。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.5\">\r\n	2.5. 怎样对一个大文件的某个字节进行直接修改\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		在ChinaUnix上看到一个帖子：<a href=\"http://bbs2.chinaunix.net/viewthread.php?tid=1469980&extra=&page=1\">http://bbs2.chinaunix.net/viewthread.php?tid=1469980&amp;extra=&amp;page=1</a>\r\n	</li>\r\n	<li>\r\n		比如我想把一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值），不用C的话，有没有现成的工具可以用啊？\r\n	</li>\r\n	<li>\r\n		实现：echo A | dd of=bigfile seek=$i bs=1 count=1 conv=notrunc\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 系统提供的特殊输入输出\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		以上的例子中涉及到以下三个输入输出\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				/dev/zero\r\n			</li>\r\n			<li>\r\n				/dev/urandom\r\n			</li>\r\n			<li>\r\n				/dev/null\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		/dev/zero/\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				是一个输入设备，你可你用它来初始化文件。\r\n			</li>\r\n			<li>\r\n				该设备无穷尽地提供0，可以使用任何你需要的数目--设备提供的要多的多。他可以用于向设备或文件写入字符串0。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		/dev/urandom\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				如上面的例子,该输出提供随机数.　可以用来销毁磁盘上的数据,　清除作案痕迹,　哈哈~~\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		/dev/null\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！\r\n			</li>\r\n			<li>\r\n				它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。\r\n			</li>\r\n			<li>\r\n				把/dev/null看作\"黑洞\". 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到.\r\n			</li>\r\n			<li>\r\n				/dev/null对命令行和脚本都非常的有用\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. dd 的主要选项\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	1.1. 说明\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	指定数字的地方若以下列字符结尾, 则乘以相应的数字:\r\n</p>\r\n<p>\r\n	b=512, c=1, k=1024, w=2, xm=number m\r\n</p>\r\n<p>\r\n	1.2. 选项\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	if=file\r\n</p>\r\n<p>\r\n	输入文件名，缺省为标准输入。\r\n</p>\r\n<p>\r\n	of=file\r\n</p>\r\n<p>\r\n	输出文件名，缺省为标准输出。\r\n</p>\r\n<p>\r\n	ibs=bytes\r\n</p>\r\n<p>\r\n	一次读入 bytes 个字节(即一个块大小为 bytes 个字节)。\r\n</p>\r\n<p>\r\n	obs=bytes\r\n</p>\r\n<p>\r\n	一次写 bytes 个字节(即一个块大小为 bytes 个字节)。\r\n</p>\r\n<p>\r\n	bs=bytes\r\n</p>\r\n<p>\r\n	同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。\r\n</p>\r\n<p>\r\n	cbs=bytes\r\n</p>\r\n<p>\r\n	一次转换 bytes 个字节，即转换缓冲区大小。\r\n</p>\r\n<p>\r\n	skip=blocks\r\n</p>\r\n<p>\r\n	从输入文件开头跳过 blocks 个块后再开始复制。\r\n</p>','','2','4','blog','8','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('23','git的常用命令','1373375061','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. git简介\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		关于Git的简介,我就不说了,网上一大堆.　Git就是编程的神器,代码管理不可缺少的东东,自从出现秒杀一切,神么csv, svn 等等,靠边站.\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 命令备忘\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. 常用命令备忘\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		git branch\r\n	</li>\r\n	<li>\r\n		git fetch origin\r\n	</li>\r\n	<li>\r\n		git checkout -b tmp origin/master\r\n	</li>\r\n	<li>\r\n		git rebase origin/master\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. git删除远程分支\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		git push origin :\r\n	</li>\r\n	<li>\r\n		git push origin --delete\r\n	</li>\r\n	<li>\r\n		git push origin :# 待验证.\r\n	</li>\r\n	<li>\r\n		git push origin --delete tag\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.3\">\r\n	2.3. git远程分支操作\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		git branch -a\r\n	</li>\r\n	<li>\r\n		git remote show origin\r\n	</li>\r\n	<li>\r\n		在本地版本库中删除所有远程版本库中已不存在的分支\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ git remote prune origin\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.4\">\r\n	2.4. tag操作相关\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		新建一个新TAG\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ git tag -a\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		推送分支到远程服务器\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ git push origin tagname\r\n			</li>\r\n			<li>\r\n				$ git push origin --tags # 推送本地所有分支到远程服务器\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		从远程服务器上取得分支\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				$ git fetch origin tag\r\n			</li>\r\n			<li>\r\n				$ git fetch origin --tags\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.5\">\r\n	2.5. 多个远程库的操作\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		添加一个新的远程仓库\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				git remote add origin \'git@gitcafe.com:zzqhost/chuannimei.git\'\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 操作实例\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\r\n	3.1. 迁移Git仓库\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		以前有一个项目在bitbucket上,但后来bitbucket被墙了,很痛苦,所以就想转移到其它的托管服务器上.　目前选定了gitcafe.\r\n	</li>\r\n	<li>\r\n		步骤\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				cd existing_git_repo\r\n			</li>\r\n			<li>\r\n				git remote add origin \'git@gitcafe.com:zzqhost/chuannimei.git\'\r\n			</li>\r\n			<li>\r\n				git push -u origin master\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		按以上步骤把需要的分支都搞好.\r\n	</li>\r\n	<li>\r\n		然后再把所有的分支push到gitcafe上.\r\n	</li>\r\n	<li>\r\n		好,大功造成.\r\n	</li>\r\n</ul>','<p>\r\n	1. git简介\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	关于Git的简介,我就不说了,网上一大堆.　Git就是编程的神器,代码管理不可缺少的东东,自从出现秒杀一切,神么csv, svn 等等,靠边站.\r\n</p>\r\n<p>\r\n	2. 命令备忘\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2.1. 常用命令备忘\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	git branch\r\n</p>\r\n<p>\r\n	git fetch origin\r\n</p>\r\n<p>\r\n	git checkout -b tmp origin/master\r\n</p>\r\n<p>\r\n	git rebase origin/master\r\n</p>\r\n<p>\r\n	2.2. git删除远程分支\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	git push origin :\r\n</p>\r\n<p>\r\n	git push origin --delete\r\n</p>\r\n<p>\r\n	git push origin :# 待验证.\r\n</p>\r\n<p>\r\n	git push origin --delete tag\r\n</p>','','2','6','blog','6','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('24','流媒体中用到的几个协议简介','1373375083','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 由来\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		电视会议是近年兴起的一种通信方式。随着技术的进步，电视会议的发展可以划分为４个浪潮：\r\n		<ol>\r\n			<li>\r\n				第１个浪潮是拨号群组电视会议系统；\r\n			</li>\r\n			<li>\r\n				第２个浪潮是基于ISDN的电视会议系统；\r\n			</li>\r\n			<li>\r\n				第３个浪潮是LAN上的组播电视会议系统，它被设计成多用户参与方式，使用户加入或退出会议变得非常简单。\r\n			</li>\r\n			<li>\r\n				随着internet在全球的迅猛发展，基于internet的多媒体会议系统将成为第４个浪潮，也是未来最大的一个浪潮;\r\n			</li>\r\n		</ol>\r\n	</li>\r\n	<li>\r\n		为了解决internet上多媒体会议系统所面临的问题，internet工程任务组（ＩＥＴＦ）先后制定了许多协议:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				如用于传输层的实时传输协议（ＲＴＰ）和实时传输控制协议（ＲＴＲＰ）;\r\n			</li>\r\n			<li>\r\n				会话管理的会话描述协议（ＳＤＰ）、会话发布协议（ＳＡＰ）和会话启动协议（ＳＩＰ）等等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 制定组织介绍\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. IETF\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		IETF是internet工程任务组（Internet Engineering Task Force）的简称。由网络设计者、研究者、运营者及众多厂商组成的开放式国际团体，是internet 体系结构委员会(IAB)在协议设计、开发及标准化等方面的\"臂膀\"。\r\n	</li>\r\n	<li>\r\n		IETF的实际技术工作由其下设的工作组来完成，大部分工作都通过邮件列表（mailinglists）来处理。IETF每年举行３次会议。目前IETF下设１２６个工作组，每个工作组都有一个专题,比如：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ｉｎｔｅｒｎｅｔ传真\r\n			</li>\r\n			<li>\r\n				ＩＰ电话\r\n			</li>\r\n			<li>\r\n				ＴＣＰ实现\r\n			</li>\r\n			<li>\r\n				ＩＰ安全协议\r\n			</li>\r\n			<li>\r\n				资源分配协议\r\n			</li>\r\n			<li>\r\n				超文本传输协议（ＨＴＴＰ）\r\n			</li>\r\n			<li>\r\n				等等\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		IETF是一个致力于internet 体系结构的演进以及促进internet 发展的标准化组织，它与ITU-T的不同之处在于:\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				ITU-T侧重于电信网，其成员由各国派驻，并包括一部分厂商代表\r\n			</li>\r\n			<li>\r\n				IETF侧重于internet，并且更加开放\r\n			</li>\r\n			<li>\r\n				IETF的标准化成果对internet的发展起着重要的作用，而且随着电信网与计算机网的不断融合，IETF和ITU-T彼此之间的协作也在增多，有的ＩＥＴＦ协议已被ＩＴＵ－Ｔ接纳，如ＲＴＰ协议就用在Ｈ．３２３中。因此，了解ＩＥＴＦ的相关协议，无论对生产厂商还是一般的网络与通信技术人员，都是一种必要的技术储备。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. MMUSIC\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MMUSIC: Multiparty MUltimedia SessIon Control, 是IETF下设工作组中的其中一个\r\n	</li>\r\n	<li>\r\n		MMUSIC工作组的主要任务是开发Ｉｎｔｅｒｎｅｔ标准ｔｒａｃｋ协议以支持Ｉｎｔｅｒｎｅｔ上多媒体会议的会话（ｓｅｓｓｉｏｎ）\r\n	</li>\r\n	<li>\r\n		重点开发支持组播干线（Ｍｂｏｎｅ）上的松散控制型会议的一系列协议，但也确保开发出的协议可通用于管理紧密控制型会议的会话。\r\n	</li>\r\n	<li>\r\n		至今，ＭＭＵＳＩＣ已起草了以下协议：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				会话描述协议（ＳＤＰ）和会话发布协议（ＳＡＰ）--发布会话描述；\r\n			</li>\r\n			<li>\r\n				ＳＡＰ安全--提供会话发布的安全；\r\n			</li>\r\n			<li>\r\n				实时流协议（ＲＴＳＰ）--控制实时数据的点播递交；\r\n			</li>\r\n			<li>\r\n				会话启动协议（ＳＩＰ）--启动会话与邀请用户；\r\n			</li>\r\n			<li>\r\n				简单会议控制协议（ＳＣＣＰ）--管理紧密控制型会话。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MMUSIC工作组在起草协议过程中，与多媒体会议有关的其他ＩＥＴＦ工作组及ＩＴＵ标准团体、工业标准化组织等密切联系，共同协作，以确保不同标准间的互操作性（如ＳＩＰ／ＳＡＰ／ＳＤＰ与ＩＴＵ－Ｔ Ｈ．３２３、Ｈ．３３２间的互操作性）\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 协议栈介绍\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\r\n	3.1. SDP\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		SDP也是MMUSIC工作组的一个产品,在MBONE内容中用得很多。\r\n	</li>\r\n	<li>\r\n		其目的就是在媒体会话中，传递媒体流信息，允许会话描述的接收者去参与会话。\r\n	</li>\r\n	<li>\r\n		SDP基本上在internet上工作。\r\n	</li>\r\n	<li>\r\n		他定义了绘画描述的统一格式,但并不定义多播地址的分配和SDP消息的传输,也不支持媒体编码方案的协商,这些功能均由下层传送协议完成.\r\n	</li>\r\n	<li>\r\n		典型的会话传送协议包括:SAP(Session Announcement Protocol 会话公告协议),SIP,RTSP,HTTP,和使用MIME的E-Mail.(注意:对SAP只能包含一个会话描述,其它会话传诵协议的SDP可包含多个绘画描述)\r\n	</li>\r\n	<li>\r\n		SDP包括以下一些方面：\r\n		<ol>\r\n			<li>\r\n				会话的名称和目的\r\n			</li>\r\n			<li>\r\n				会话存活时间\r\n			</li>\r\n			<li>\r\n				包含在会话中的媒体信息，包括：\r\n				<ol>\r\n					<li>\r\n						媒体类型(video, audio, etc)\r\n					</li>\r\n					<li>\r\n						传输协议(RTP/UDP/IP, H.320, etc)\r\n					</li>\r\n					<li>\r\n						媒体格式(H.261 video, MPEG video, etc)\r\n					</li>\r\n					<li>\r\n						多播或远端（单播）地址和端口\r\n					</li>\r\n				</ol>\r\n			</li>\r\n			<li>\r\n				为接收媒体而需的信息(addresses, ports, formats and so on)\r\n			</li>\r\n			<li>\r\n				使用的带宽信息\r\n			</li>\r\n			<li>\r\n				可信赖的接洽信息（Contact information）\r\n			</li>\r\n		</ol>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.2\">\r\n	3.2. SAP\r\n</h3>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.3\">\r\n	3.3. SIP\r\n</h3>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.4\">\r\n	3.4. RTSP\r\n</h3>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.5\">\r\n	3.5. RTP\r\n</h3>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.6\">\r\n	3.6. HTTP\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		http协议并不是专门为流媒体设计的，但是目前也有一些上层的应用方式，可以用它来进行在线播放，如下：\r\n		<ol>\r\n			<li>\r\n				http progressive download\r\n			</li>\r\n			<li>\r\n				http live streaming\r\n			</li>\r\n		</ol>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\r\n	4. 移动互联网中应用较为广泛的三种流媒体协议\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.4.1\">\r\n	4.1. 三种协议介绍\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		HTTP渐进下载流媒体播放\r\n	</li>\r\n	<li>\r\n		RTSP/RTP流媒体协议\r\n	</li>\r\n	<li>\r\n		HTTP Live Streaming协议\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.4.2\">\r\n	4.2. 对比及应用范围\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		注：　这里的内容还没有写完，只列了一个框架，以后有时间我会补充的。　或者Google 《移动流媒体协议综述》, 里边有详细介绍。\r\n	</li>\r\n</ul>','<p>\r\n	1. 由来\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	电视会议是近年兴起的一种通信方式。随着技术的进步，电视会议的发展可以划分为４个浪潮：\r\n</p>\r\n<p>\r\n	第１个浪潮是拨号群组电视会议系统；\r\n</p>\r\n<p>\r\n	第２个浪潮是基于ISDN的电视会议系统；\r\n</p>\r\n<p>\r\n	第３个浪潮是LAN上的组播电视会议系统，它被设计成多用户参与方式，使用户加入或退出会议变得非常简单。\r\n</p>\r\n<p>\r\n	随着internet在全球的迅猛发展，基于internet的多媒体会议系统将成为第４个浪潮，也是未来最大的一个浪潮;\r\n</p>\r\n<p>\r\n	为了解决internet上多媒体会议系统所面临的问题，internet工程任务组（ＩＥＴＦ）先后制定了许多协议:\r\n</p>\r\n<p>\r\n	如用于传输层的实时传输协议（ＲＴＰ）和实时传输控制协议（ＲＴＲＰ）;\r\n</p>\r\n<p>\r\n	会话管理的会话描述协议（ＳＤＰ）、会话发布协议（ＳＡＰ）和会话启动协议（ＳＩＰ）等等。\r\n</p>\r\n<p>\r\n	2. 制定组织介绍\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	2.1. IETF\r\n</p>','','2','5','blog','8','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('25','DRM标准学习笔记1','1373375107','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 缘起\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		旱就听说过DRM，但一直不知道具体的详细内容及实现，现在终于要用到它了，所以做了一个系统的了解及学习。\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 技术方案(标准)\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		数字版权管理DRM技术是通过一定的安全算法/协议与安全管理手段实现对数字内容（电子书、视频、音频和图片等）的保护，使数字内容在未经授权和允许的条件下不能使用、复制和分发等。DRM不仅处理内容的物理传送，还对内容的整个生命期进行管理和控制。将DRM技术引入移动通信业务，可以确保数字内容在移动网内的传播，保证内容提供商的利益。\r\n	</li>\r\n	<li>\r\n		现有的DRM技术方案很多，标准化方案主要包括：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				OMA DRM 1.0、\r\n			</li>\r\n			<li>\r\n				OMA DRM 2.0、\r\n			</li>\r\n			<li>\r\n				Marlin，\r\n			</li>\r\n			<li>\r\n				以及微软DRM等私有方案。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. OMA DRM\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\r\n	3.1. OMA DRM介绍\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		OMA（Open Mobile Alliance，开放式移动体系结构）正式成立于2002年6月初，其前身为：Open Mobile Architecture Initiative supporters和WAP Forum。后续有一些组织加入了OMA，包括Wireless Village，MGIF（Mobile Gaming Interoperability Forum），Sync ML Initiative，MWIF（Mobile Wireless Internet Forum），MMSIOP和LIF（Location Interoperability Forum）。OMA的主要任务是收集市场需求并制定规范，清除互操作性发展的障碍，并加速各种全新的增强型移动信息、通信和娱乐服务及应用的开发和应用。OMA代表了无线通信业的革新趋势，它鼓励价值链上所有的成员通过更大程度地参与行业标准的制定，建立更为完整的、端到端的解决方案。\r\n	</li>\r\n	<li>\r\n		目前OMA已经超过400多个来自全球的成员单位，构成了完整的移动业务价值链，包括移动运营商、无线设备提供商、信息技术公司和内容提供商等主要的4大类成员单位。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		OMA组织于2002年9月发布了OMA DRM V1.0，于2006年3月发布了OMA DRM V2.0。OMA DRM标准是完全开放的，目前大部分运营商都已经采用或计划采用OMA DRM标准。\r\n	</li>\r\n	<li>\r\n		DRM v1.0标准定义的是一个初级的DRM系统，基本能够满足Forward Lock、Combined Delivery、Separate Delivery方式的商用需求；\r\n	</li>\r\n	<li>\r\n		而其它版本是一个更加复杂和安全的DRM系统，如OMADRM2.0增强支持Combined Delivery、Separate Delivery等方式和流媒体业务，满足规模商用的需求；\r\n	</li>\r\n	<li>\r\n		OMA DRM2.1在2.0版本的基础上进行了进一步增强。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.2\">\r\n	3.2. OMA DRM 1.0\r\n</h3>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.3.2.1\">\r\n	3.2.1. 概述\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		OMA DRM 1.0是OMA组织推出的最早的版本，其内容保护方式主要有：转发锁定、组合分发、分离发送和超级分发。分别阐述如下：\r\n		<ol>\r\n			<li>\r\n				禁止转发。一个媒体对象被封装在一个DRM消息中传输给设备，允许设备使用内容，但是内容不能转发到其他设备，且设备不能修改此媒体对象。\r\n			</li>\r\n			<li>\r\n				组合发送。一个权限对象和一个媒体对象被封装在一个DRM消息中发送给设备，设备可以根据权限对象的规定向用户提供内容，但不能修改、转发权限对象和媒体对象。\r\n			</li>\r\n			<li>\r\n				分别发送。内容对象打包成一种特殊的DRM内容格式（DRM Content Format，DCF），采用对称加密技术，必须使用内容密钥（Content Encryption Key，CEK）才能够访问媒体内容，CEK存储在版权对象中。这样，内容可以经过非安全的传输途径传送，而版权对象的传送则需要更高安全性的传输通道。\r\n			</li>\r\n			<li>\r\n				超级分发。超级发送是分别发送的一种特殊应用方式。在这种模式下，终端之间可以通过任何可能的途径传送媒体对象，而版权对象只能通过WAP Push从版权发布服务器获得。这样就在不危及任何版权维护的商业模式的条件下，极大地鼓励了用户之间更加方便地共享媒体对象。\r\n			</li>\r\n		</ol>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		OMA DRM 1.0的基本特点如下：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				内容保护方式：转发锁定、组合分发、分离发送、超级分发\r\n			</li>\r\n			<li>\r\n				下载方式：内容下载采用HTTP下载或OMA下载。RO下载采用WAP PUSH。组合发送与分离发送，RO都不加密。RO存在延时问题\r\n			</li>\r\n			<li>\r\n				媒体格式：除流媒体外，对媒体格式没有限制，依赖于终端的播放器支持\r\n			</li>\r\n			<li>\r\n				功能方面：\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						由于不支持分断加密，因此不支持片断预览模式。\r\n					</li>\r\n					<li>\r\n						只能在手机之间共享，不支持域共享\r\n					</li>\r\n					<li>\r\n						支持音乐、视频、软件、游戏、图片等多种业务模式。只适用于下载业务领域，如：OMA下载和HTTP下载。不支持广告模式。使用Wap Push获取权限，用户感受差\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				方全问题：无安全时钟、RO不加密、RO无完整性保护等\r\n			</li>\r\n			<li>\r\n				商用成熟度：终端支持程序高，已经有大量的运营商商用案例\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		总体上，OMA DRM 1.0保护方式较少，用户体验一般，不支持域及分段预览，流媒体，业务模式少；安全性较弱；商用成熟度高。由于OMA DRM 1.0的安全性问题，使得OMA DRM 1.0主要应用于低价值内容的保护。OMA DRM 1.0仅被推荐应用于图片、铃声等小附加值内容保护。目前Vadafone，Orange（MusicWave），T-Mobile Europe，Cingular，T-Mobile USA等运营商已经有商用案例。\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.3.2.2\">\r\n	3.2.2. 详细流程\r\n</h4>\r\n<h5 style=\"color:#989898;text-indent:0px;\" id=\"toc_1.3.2.2.1\">\r\n	3.2.2.1. 应用\r\n</h5>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		OMA中关于DRM的定义主要是为了给内容提供商提供一种控制媒体对象使用的方式，包括对DRM Message的预览、保护文件、防止非法拷贝、超级传送（一种合法的拷贝方式）。\r\n	</li>\r\n	<li>\r\n		在DRM的范畴内，为了保证媒体对象的合法使用，一旦对象被下载，就被DRM Agent（通常是运行在移动终端上，实现DRM控制）接管了。\r\n	</li>\r\n	<li>\r\n		DRM系统允许内容提供商给不同的媒体对象添加不同的版权对象，同一媒体对象也允许添加不同的版权对象，由此，内容提供商就可以根据不同的版权对象来定价，客户们根据定价进行消费，于是，一套合理的电子消费系统就产生了。内容提供商会提供用户预览DRM Message的版权对象，一些精彩的预览画面往往会吸引更多的消费者。\r\n	</li>\r\n	<li>\r\n		应该这么来理解，版权对象和媒体对象都可以看作实体，受保护的媒体对象可以较容易获得，但是版权对象则需要单独购买。有了版权对象才能播放受保护的媒体对象。\r\n	</li>\r\n</ul>\r\n<h5 style=\"color:#989898;text-indent:0px;\" id=\"toc_1.3.2.2.2\">\r\n	3.2.2.2. 获得的四种方式\r\n</h5>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		关于版权对象和媒体对象的获得主要是以下三种方式：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Forward-lock\r\n			</li>\r\n			<li>\r\n				Combined delivery\r\n			</li>\r\n			<li>\r\n				Separate delivery\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		前两种方式是：Forward-lock，即转发锁定；Combined delivery，即组合发送。这两种方式都需要将媒体文件打包，如果是使用第二种方式，还需要将版权对象和媒体文件打包在一个文件中。DRM Agent根据版权对象来播放媒体对象，如果未包含版权对象，则根据DRM Agent中设置的默认版权进行播放。\r\n	</li>\r\n	<li>\r\n		第三种方式是Separate delivery，即分组发送。将媒体对象打包成OMA DRM V1.0中规定的DCF（DRM Content Format）格式，使用对称密钥加密。若要播放媒体文件，只有获得CEK（Content Encryption Key），进行解密。因此，在传送DCF文件时，可以使用安全性较低的通信方式，在传送版权对象以及CEK时，则需要一种安全性高的方式。在1.0版本中，使用短信推送的方式，将版权对象发送给移动终端。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		根据分组发送，OMA DRM V1.0中提出了超级分发的概念。允许在多个移动终端之间传递DCF文件，但是并不能传递版权对象。当未包含版权对象的移动终端接收到DCF文件后，会根据文件中的定义，访问对应的版权对象服务器，提示用户购买相应的版权对象并下载。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		支持转发锁定方式的移动终端需要支持的媒体对象格式为：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				application/vnd.oma.drm.message。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		支持组合发送方式的移动终端需要支持的媒体对象格式为：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				application/vnd.oma.drm.message\r\n			</li>\r\n			<li>\r\n				application/vnd.oma.drm.rights+xml\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		支持分组发送方式的移动终端需要支持的媒体对象格式为：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				application/vnd.oma.drm.content\r\n			</li>\r\n			<li>\r\n				application/vnd.oma.drm.rights+xml\r\n			</li>\r\n			<li>\r\n				application/vnd.oma.drm.rights+wbxml\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h5 style=\"color:#989898;text-indent:0px;\" id=\"toc_1.3.2.2.3\">\r\n	3.2.2.3. 传送对象的不同\r\n</h5>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		转发锁定：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在转发锁定方式中，移动终端是禁止转发DRM Message的（DRM Message是讲媒体对象打包后生成的文件，但是没有加密，明文存储）。必须支持DRM Message文件格式。如果移动终端接收到一个包含版权对象的DRM Message（在组合发送方式中，处理的对象是包含版权对象的DRM Message），则需要在提示用户后，将该DRM Message抛弃。移动终端可以播放媒体对象，但是不能对其修改。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		组合发送：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				支持组合发送方式的移动终端必须支持转发锁定方式，在该方式中，移动终端根据版权对象来播放媒体对象。版权对象和媒体对象通过被包装在同一个DRM Message中。对于这两个对象本身来说，其关联是外部的，因此移动终端必须保证在收到DRM Message并可能拆包后丢弃的情况下，永久保存版权对象。移动终端不得将组合发送方式中的媒体对象转发。当移动终端使用下载内容时，必须遵循用版权对象描述语言\"Rights Expression Language\"描述的规定。REL控制下载内容的使用，例如下载媒体对象是否仅被允许打开一次等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		分组发送：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				支持分组发送的DRM Agent必须支持组合发送和转发锁定，在分组发送中，媒体对象通常是通过加密的，并转换为DCF格式。DCF文件通过OMA Download方式下载到设备上，版权对象则通过其他的途径送达（WAP Push）。在分组发送中，允许设备将DCF文件转发，但是版权对象是不允许转发的，接收到DCF文件的其他设备需要从Right Issuer获取版权对象。移动终端必须同时支持版权和DRM内容格式（DCF）媒体类型。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h5 style=\"color:#989898;text-indent:0px;\" id=\"toc_1.3.2.2.4\">\r\n	3.2.2.4. 举例\r\n</h5>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		转发锁定方式中，服务器端返回的DRM Message\r\n<pre>Content-type: application/vnd.oma.drm.message;\r\nboundary=boundary-1\r\nContent-Length: 574\r\n--boundary-1\r\nContent-type: image/jpeg\r\nContent-Transfer-Encoding: binary\r\n...jpeg image in binary format...\r\n--boundary-1-\r\n</pre>\r\n	</li>\r\n	<li>\r\n		在组合方式中，服务器端返回的DRM Message\r\n<pre>HTTP/1.1 200 OK\r\nContent-type: application/vnd.oma.drm.message;\r\nboundary=boundary-1\r\nContent-Length: 893\r\n--boundary-1\r\nContent-type: application/vnd.oma.drm.rights+xml\r\nContent-Transfer-Encoding: binary1.0cid:4567829547@foo.bar--boundary-1\r\nContent-type: image/jpeg\r\nContent-ID: &lt;45678929547@foo.bar&gt;\r\nContent-Transfer-Encoding: binary\r\n...jpeg image in binary format...\r\n--boundary-1-\r\n</pre>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		分组发送方式中，服务器端返回的DRM Message\r\n<pre>HTTP/1.1 200 OK\r\nContent-type: application/vnd.oma.drm.content;\r\nContent-Length: 1234\r\nX-Oma-Drm-Separate-Delivery: 12\r\n...DRM content in DCF format...\r\n</pre>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\r\n	4. 参考链接\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		<a href=\"http://labs.chinamobile.com/mblog/165_19568\">http://labs.chinamobile.com/mblog/165_19568</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://blog.csdn.net/jiyucn/article/details/1671656\">http://blog.csdn.net/jiyucn/article/details/1671656</a> \r\n	</li>\r\n</ul>','<p>\r\n	1. 缘起\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	旱就听说过DRM，但一直不知道具体的详细内容及实现，现在终于要用到它了，所以做了一个系统的了解及学习。\r\n</p>\r\n<p>\r\n	2. 技术方案(标准)\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	数字版权管理DRM技术是通过一定的安全算法/协议与安全管理手段实现对数字内容（电子书、视频、音频和图片等）的保护，使数字内容在未经授权和允许的条件下不能使用、复制和分发等。DRM不仅处理内容的物理传送，还对内容的整个生命期进行管理和控制。将DRM技术引入移动通信业务，可以确保数字内容在移动网内的传播，保证内容提供商的利益。\r\n</p>\r\n<p>\r\n	现有的DRM技术方案很多，标准化方案主要包括：\r\n</p>\r\n<p>\r\n	OMA DRM 1.0、\r\n</p>\r\n<p>\r\n	OMA DRM 2.0、\r\n</p>\r\n<p>\r\n	Marlin，\r\n</p>\r\n<p>\r\n	以及微软DRM等私有方案。\r\n</p>','','2','5','blog','6','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('26','DRM标准学习笔记2－ForwardLock原理及实现','1373375129','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. ForwardLock\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		ForwardLock 是DRM1.0中最简单的一种传输方式。请参考<a href=\"http://zzqhost.com/多媒体相关_DRM标准学习笔记1.html\">DRM标准学习笔记1</a> \r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. ForwardLock工作流程\r\n</h2>\r\n<ol style=\"color:#000000;text-indent:0px;\">\r\n	<li>\r\n		用特定工具，或者是手动编写，将一个普通的视频文件（例如mp4) 生成一个符合标准的DRM文件，放到服务器上；\r\n	</li>\r\n	<li>\r\n		用户付费后，用下载工具将此DRM文件下载到本地；\r\n	</li>\r\n	<li>\r\n		下载工具必须支持这种DRM文件，下载的时候，其内部实际上是把此DRM文件进行了加密，加密算法可以采用AES等算法。密钥应该是每台机器生成一个唯一的密钥，加密和解密密钥是相同的。\r\n	</li>\r\n	<li>\r\n		这样，在本地端就有了一个加密的媒体文件，用户可以在本机上进行播放，但如果COPY到另外的机器上，由于密钥不同，所以不以成功解密，这样就达到了ForwardLock的目的。\r\n	</li>\r\n</ol>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 符合ForwardLocak标准的DRM文件格式\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		如下所示的格式：\r\n<pre>    --boundary12345\\r\\n\r\n    Content-type: video/mp4\\r\\n\r\n    Content-Transfer-Encoding: binary\\r\\n\r\n    \\r\\n\r\n      .\r\n      .\r\n      .\\r\\n\r\n    --boundary12345--\\r\\n\r\n</pre>\r\n	</li>\r\n	<li>\r\n		说明：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				DRM文件格式其实就是在原始的媒体文件加了一个头和一个尾。如上所示。\r\n			</li>\r\n			<li>\r\n				头一共增加了四行，在这里我把隐藏字符也用转义字写出来，目的就是为了看清楚。\r\n			</li>\r\n			<li>\r\n				第一行是以--开头，后跟一个随机的字符串，但结尾时也必须是这个字符串。然后是回车换行。\r\n			</li>\r\n			<li>\r\n				第二行是说明此文件的mime type是什么\r\n			</li>\r\n			<li>\r\n				第三行说的是编码格式，是二进制，还是64 base。\r\n			</li>\r\n			<li>\r\n				第四行是一个空行。\r\n			</li>\r\n			<li>\r\n				然后是原始的媒体文件，这里用三个点的三行来进行表示。\r\n			</li>\r\n			<li>\r\n				最后，在原始文件的末尾先来一个回车换行\r\n			</li>\r\n			<li>\r\n				最后一行是以--开头和结尾，中间放上跟头一样的字符串，回车换行。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.4\">\r\n	4. Android中如何实现ForwardLocak?\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		最后，目前的Android代码（Android4.1JB）是支持此功能的，即通过Browser下载的时候，如果是FrowardLocak文件则会进行文件的加密。\r\n	</li>\r\n	<li>\r\n		如果想自己写一个来玩玩，可以用以下的代码实现：\r\n<pre>    mDrmManagerClient = new DrmManagerClient();\r\n    mConvertSessionID = mDrmManagerClient-&gt;openConvertSession(s_imetype);\r\n\r\n    ...\r\n\r\n    DrmBuffer buffer((char *)data, (int)size);\r\n    DrmConvertedStatus *convertedStatus =\r\n           mDrmManagerClient-&gt;convertData(mConvertSessionID, &amp;buffer);\r\n\r\n    int write_len = writeConvertedStatusToFile(convertedStatus, mDrmOffset + offset);\r\n\r\n    ...\r\n\r\n    // close drm session and write drm file size.\r\n    convertedStatus = mDrmManagerClient-&gt;closeConvertSession(mConvertSessionID);\r\n    writeConvertedStatusToFile(convertedStatus);\r\n\r\n    // delete the instance.\r\n    delete mDrmManagerClient;\r\n    mDrmManagerClient=NULL;\r\n</pre>\r\n	</li>\r\n	<li>\r\n		说明：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				writeConvertedStatusToFile是我写的一个处理转换结果的私有函数，主要是把结果convertedStatus中的数据进行保存。\r\n			</li>\r\n			<li>\r\n				在最后，关闭ConvertSession后，还会返回一个convertedStatus，这里边也包含数据，并且多包含了一个offset，位置正好位于头部，这里存的是整个文件的大小，因为大小只有在整个转换完成，关闭时才会知道。\r\n			</li>\r\n			<li>\r\n				另外，如果想对一个普通的媒体文件进行加密，则需要自己加上DRM的头和尾然后用此类的实例进行转换。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.5\">\r\n	5. Android中DRM代码结构分析\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		代码位置\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				frameworks/base/drm/ (DRM的Java和JNI代码)\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						java/\r\n					</li>\r\n					<li>\r\n						jni/\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				frameworks/av/drm/ (DRM的Native层代码，包括引擎和服务)\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						common/\r\n					</li>\r\n					<li>\r\n						drmserver/\r\n					</li>\r\n					<li>\r\n						libdrmframework/\r\n						<ul style=\"margin-left:2em;\">\r\n							<li>\r\n								DrmManagerClient.cpp\r\n							</li>\r\n							<li>\r\n								include/\r\n							</li>\r\n							<li>\r\n								plugins/\r\n							</li>\r\n						</ul>\r\n					</li>\r\n				</ul>\r\n			</li>\r\n			<li>\r\n				frameworks/base/media/ (此路径中有关DRM的代码可能是遗留代码，目前还不知道有什么用)\r\n				<ul style=\"margin-left:2em;\">\r\n					<li>\r\n						libdrm/mobile1/\r\n					</li>\r\n					<li>\r\n						java/drm/\r\n					</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>','<p>\r\n	1. ForwardLock\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	ForwardLock 是DRM1.0中最简单的一种传输方式。请参考DRM标准学习笔记1\r\n</p>\r\n<p>\r\n	2. ForwardLock工作流程\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	用特定工具，或者是手动编写，将一个普通的视频文件（例如mp4) 生成一个符合标准的DRM文件，放到服务器上；\r\n</p>\r\n<p>\r\n	用户付费后，用下载工具将此DRM文件下载到本地；\r\n</p>\r\n<p>\r\n	下载工具必须支持这种DRM文件，下载的时候，其内部实际上是把此DRM文件进行了加密，加密算法可以采用AES等算法。密钥应该是每台机器生成一个唯一的密钥，加密和解密密钥是相同的。\r\n</p>\r\n<p>\r\n	这样，在本地端就有了一个加密的媒体文件，用户可以在本机上进行播放，但如果COPY到另外的机器上，由于密钥不同，所以不以成功解密，这样就达到了ForwardLock的目的。\r\n</p>','','2','5','blog','7','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('27','多媒体编解码基础知识','1373375163','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 多媒体格式分类\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		多媒体的格式包括三种：封装格式、视频编解码、音频编解码。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.1\">\r\n	1.1. 多媒体封装格式(又称容器）\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		所谓封装格式就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中，也就是说仅仅是一个外壳，或者大家把它当成一个放视频轨和音频轨的文件夹也可以。\r\n	</li>\r\n	<li>\r\n		说得通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个碗，或者一个锅，用来盛放饭菜的容器。有的人可能觉得奇怪，容器，不就能盛放饭菜就行了么，用一个碗就可以了，何必制定出这么多的格式以及规范呢？\r\n	</li>\r\n	<li>\r\n		其实不然，试想一下，有的菜，例如排骨，比较大，碗放不下，得换锅。有的饭比较烫，也不能放在塑料的容器里，当然个人喜好也有一定关系。所以容器的选择，基本在于，其对视频/音频兼容性，以及适合范围。这下大家应该明白了，很多人一直把封装格式当成视频编码，而这两者之间没有必然的直接联系。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.2\">\r\n	1.2. 视频编解码器\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		是指一个能够对数字视频进行压缩或者解压缩的程序或者设备。通常这种压缩属于有损数据压缩。历史上，视频信号是以模拟形式存储在磁带上的。随着Compact Disc的出现并进入市场，音频信号以数字化方式进行存储，视频信号也开始使用数字化格式，一些相关技术也开始随之发展起来。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.1.3\">\r\n	1.3. 音频编解码器\r\n</h3>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 常见的格式介绍\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.1\">\r\n	2.1. 封装格式\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MPG\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG 编码采用的容器，具有流的特性。里面又分为 PS，TS 等，PS 主要用于 DVD 存储，TS 主要用于 HDTV。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		VOB\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				DVD 采用的容器格式，支持多视频多音轨多字幕章节等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MP4\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG-4编码采用的容器，基 于 QuickTime MOV 开发，具有许多先进特性。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3GP\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				3GPP视频采用的格式， 主要用于流媒体传送。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		ASF\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Windows Media 采用的容器，能够用于流传送，还能包容脚本等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		RM\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				RealMedia 采用的容器，用于流传送。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MOV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				QuickTime 的容器，恐怕也是现今最强大的容器，甚至支持虚拟现实技术，Java等，它的变种 MP4,3GP都没有这么厉害。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MKV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MKV它能把 Windows Media Video，RealVideo，MPEG-4 等视频音频融为一个文件，而且支持多音轨，支持章节字幕等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		OGG\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ogg 项目采用的容器，具有流的特性，支持多音轨，章节，字幕等。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		OGM\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ogg 容器的变种，能够支持基于 DirectShow 的视频音频编码，支持章节等特性。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		AVI\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				最常见的音频视频容器。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		NSV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Nullsoft Video 的容器，用于流传送。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		WAV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				一种音频容器，大家常说的 WAV 就是没有压缩的 PCM 编码，其实 WAV 里面还可以包括 MP3 等其他 ACM 压缩编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h4 style=\"color:#909090;text-indent:0px;\" id=\"toc_1.2.1.1\">\r\n	2.1.1. 常见格式详细介绍及比较\r\n</h4>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		AVI\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				AVI是音频视频交错（Audio Video Interleaved）的英文缩写，它是Microsoft公司开发的一种数字音频与视频文件格式，允许视频和音频交错在一起同步播放。\r\n			</li>\r\n			<li>\r\n				AVI文件的格式是公开并且免费的，大量的视频爱好者在使用这种文件格式。很多PMP唯一能支持的格式就是AVI格式，一般的PMP都带有可以转换其他格式视频成为AVI格式的软件。\r\n			</li>\r\n			<li>\r\n				AVI文件采用的是RIFF（Resource Interchange File Format，资源互换文件格式）文件结构，RIFF是Microsoft公司定义的一种用于管理windows环境中多媒体数据的文件格式。AVI格式包括2种：AVI 1.0和Open-DML AVI。AVI 1.0为传统的AVI格式，Open-DML AVI是AVI 1.0的扩展。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		ASF\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				ASF(Advanced Systems Format)是一个开放格式，它能依靠多种协议在多种网络环境下支持数据的传送。ASF是专为在IP网上传送有同步关系的多媒体数据而设计的文件格式，所以ASF格式的信息特别适合在IP网上传输。ASF支持任意的压缩/解压缩编码方式的流媒体，并可以使用任何一种底层网络传输协议，具有很大的灵活性。目前网上以wmv为后缀的文件绝大多数采用的是ASF格式，WMV是微软公司视频编码方式而不是文件格式。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		Mp4，3gp，mov\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MP4格式是ISO-IEC Mpeg-4协议Part 14中定义的容器格式。MP4格式实际上是对Apple公司开发的MOV格式(也称Quicktime格式)的一种改进，两种格式差别很小。\r\n			</li>\r\n			<li>\r\n				MOV格式广泛应用于Mac OS操作系统，在Windows操作系统上也可兼容，但是远比不上AVI格式流行。\r\n			</li>\r\n			<li>\r\n				而应用于3G手机上的音视频文件格式--3GP其实是MP4格式的一种简化版本，3GP格式是一种由3GPP组织制定的多媒体容器格式(container format)，3GPP组织形成的通讯协议是目前全世界手机厂商使用最广的，而3GP格式当然也是手机视频格式的绝对主流。\r\n			</li>\r\n			<li>\r\n				MP4，MOV，3GP格式可以说具有相同的文件结构。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MKV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				是一种开源的容器格式，目前网上流行的很多高清的视频都是以MKV打包的。 我对这种格式研究的比较深入，由于这种格式出现得比较晚，而且是开源的，所以具有先天的优势，是一种很好的容器格式。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.2\">\r\n	2.2. 视频编解码\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		H.261\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				H.261主要在老的视频会议和视频电话产品中使用。H.261是由ITU-T开发的，第一个使用的数字视频压缩标准。实质上说，之后的所有的标准视频编解码器都是基于它设计的。它使用了常见的YCbCr颜色空间，4:2:0的色度抽样格式，8位的抽样精度，16x16的宏块，分块的运动补偿，按8x8分块进行的离散余弦变换，量化，对量化系数的Zig-zag扫描，run-level符号影射以及霍夫曼编码。H.261只支持逐行扫描的视频输入。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MPEG-1第二部分\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG-1第二部分主要使用在VCD上，有些在线视频也使用这种格式。该编解码器的质量大致上和原有的VHS录像带相当，但是值得注意的是VCD属于数字视频技术，它不会像VHS录像带一样随着播放的次数和时间而逐渐损失质量。如果输入视频源的质量足够好，编码的码率足够高，VCD可以给出从各方面看都比VHS要高的质量。但是为了达到这样的目标，通常VCD需要比VHS标准要高的码率。实际上，如果考虑到让所有的VCD播放机都可以播放，高于1150kbps的视频码率或者高于352x288的视频分辨率都不能使用。大体来说，这个限制通常仅仅对一些单体的VCD播放机(包括一些DVD播放机)有效。MPEG-1第三部分还包括了目前常见的*.mp3音频编解码器。如果考虑通用性的话，MPEG-1的视频/音频编解码器可以说是通用性最高的编解码器，几乎世界上所有的计算机都可以播放MPEG-1格式的文件。几乎所有的DVD机也支持VCD的播放。从技术上来讲，比起H.261标准，MPEG-1增加了对半像素运动补偿和双向运动预测帧。和H.261一样，MPEG-1只支持逐行扫描的视频输入。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MPEG-2第二部分\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG-2第二部分等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统(cable distribution systems)中。当使用在标准DVD上时，它支持很高的图像质量和宽屏；当使用在SVCD时，它的质量不如DVD但是比VCD高出许多。但是不幸的是，SVCD最多能在一张CD光盘上容纳40分钟的内容，而VCD可以容纳一个小时，也就是说SVCD具有比VCD更高的平均码率。MPEG-2也将被使用在新一代DVD标准HD-DVD 和 Blu-ray(蓝光光盘)上。从技术上来讲，比起MPEG-1，MPEG-2最大的改进在于增加了对隔行扫描视频的支持。MPEG-2可以说是一个相当老的视频编码标准，但是它已经具有很大的普及度和市场接受度。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		H.263\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				H.263主要用在视频会议、视频电话和网络视频上。在对逐行扫描的视频源进行压缩的方面，H.263比它之前的视频编码标准在性能上有了较大的提升。尤其是在低码率端，它可以在保证一定质量的前提下大大的节约码率。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MPEG-4第二部分\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG-4第二部分标准可以使用在网络传输、广播和媒体存储上。比起MPEG-2和第一版的H.263，它的压缩性能有所提高。和之前的视频编码标准的主要不同点在于，\"物件導向\"(Object-oriented)的编码方法和一些其它并非用于提高通常视频编码压缩率的技术。当然它也引入了一些提高压缩能力的技术，包括一些H.263的技术和1/4像素的运动补偿。和MPEG-2一样，它同时支持逐行扫描和隔行扫描。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		MPEG-4第十部分\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MPEG-4第十部分技术上和ITU-T H.264是相同的标准，有时候也被叫做\"AVC\")。 这个刚刚制定完成的标准是ITU-T VCEG和ISO/IEC MPEG合作完成的性能最优的视频编码标准，并且在已经得到了越来越多的应用。该标准引入了一系列新的能够大大提高压缩性能的技术，并能够同时在高码率端和低码率端大大超越以前的诸标准。已经使用和将要使用H.264技术的产品包括例如索尼公司的PSP，Nero公司的Nero Digital 产品套装，苹果公司的Mac OS X v10.4，以及新一代DVD标准HD-DVD和蓝光光盘(Blu-ray)。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		AVS\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				AVS是中国制定的音视频压缩编码标准，故准确来说，其不仅仅包括视频编码标准。它最主要的目的是通过采用与H.264不同的专利授权方式，来避免付出大笔的专利授权费用。在技术上，AVS的视频编码部分采用的技术与H.264非常相似，但采取了一些简化措施。这样做，其一可以回避一些非必要专利，另外据称也可以在几乎不影响编码压缩效率的基础上，提高编解码速度。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		DivX，XviD和3ivx\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				DivX，XviD和3ivx视频编解码器基本上使用的都是MPEG-4第二部分的技术，以后缀*.avi, *.mp4, *.ogm 或者 *.mkv 结尾的文件有一部分是使用这些视频编解码器的。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		WMV\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				WMV（Windows Media Video）是微软公司的视频编解码器家族，包括WMV 7、WMV 8、WMV 9、WPV 10。这一族的编解码器可以应用在从拨号上网的窄带视频到高清晰度电视(HDTV)的宽带视频。使用Windows Media Video用户还可以将视频文件刻录到CD、DVD或者其它一些设备上。它也适用于用作媒体服务器。WMV 可以被看作是MPEG-4的一个增强版本。最新的WMV的版本是正在SMPTE制定中的VC-1标准。WMV-9（VC-1，开发代号为\"Corona\"）刚推出的时候称为VC-9，之后才被电影电视工程师协会(SMPTE)改称为VC-1（VC指Video Codec）。技术上，VC-1也与H.264有诸多相似之处。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		RealVideo\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				RealVideo是由RealNetworks公司开发的视频编解码器。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		Sorenson 3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Sorenson 3是由苹果公司的软件QuickTime使用的一种编解码器。很多因特网上的QuickTime格式的视频都是这种编解码器压缩的。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		Cinepak\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Cinepak同样是由苹果公司的软件QuickTime使用的一种很老的编解码器，好处是即使很老的计算机(如486)也都支援并且能顺利播放。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		Indeo Video\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Indeo Video Indeo Video 是由 Intel 所研發的编解码器。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.2.3\">\r\n	2.3. 音频编解码\r\n</h3>\r\n<p style=\"color:#000000;text-indent:0px;\">\r\n	待整理\r\n</p>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. 按照制定者(组织）介绍\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\r\n	3.1. MPEG系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MPEG a （Moving Pictures Experts Group） 运动图象专家组，属于 ISO（International Organization for Standardization） 国际标准组织，他们开发了一系列视频音频编 码，最为大家熟悉的就是 MP3，MPEG-1/2/4。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.1 MPEG-1\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				较早的视频编码，质量 比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.2 MPEG-2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在 MPEG- 1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD- Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨 率达到了 1920x1080。由于 MPEG-2 的普及，本来为 HDTV 准备的 MPEG-3 最终宣告放弃。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.3 MPEG-4\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				为了应对网络传输等环境，传统的 MPEG-1/2 已经不能适应，所以促使了 MPEG-4 的诞生。MPEG-4 采用了一系列新技术，来满足在低带宽 下传输较高视频质量的需求。DivX，XviD，MS MPEG4 都是采用的 MPEG-4 视频编码，除了在 DVDRip 上面的应 用，3GPP 现在也接纳了 MPEG-4 作为视频编码方案。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.4 MPEG-4 AVC\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				它和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要 好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编 码方案之一，相信 AVC 的发展前途会非常好。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.5 MPEG Audio Layer 1/2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				也就是 MP1、MP2 ，较早的音频编码，是 MP3 的前身，主要用于 VCD，DVD，SVCD 的音频编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.6 MPEG Audio Layer 3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				大名鼎鼎的 MP3，已经成为网络音频的主流格式，能在 128kbps 的码率接近 CD 音质。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.7 MPEG-2 AAC\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在MPEG- 2 上开发的一种新的音频编码，和传统的 MPEG Audio 不兼容，它的质量理论上高于 MP3，并且支持多声道。在 96kbps 的码率范围内 就能接近 CD 音质，比 MP3 更加适合地码率传输。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MPEG-4 AAC\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				AAC 已经作为 MPEG-4 标准的音频编码，当然 MPEG-4 Audio 还有其他多种音频编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.8 MPEG-4 aacPlus\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				采用了 SBR 频带复制技术的 AAC，SBR 技术能够让音频编码降低一半的码率而音质不会有太大改变，已经成为 MPEG-4 标准的一部分。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.9 MPEG-4 VQF\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				NTT 开发的一种音频格式，曾经销声匿迹了一段时间，只在 Nero 里面见到过它的身影。现在搭上 SBR 技术又进入了 MPEG-4 标准，似乎不甘心就这 么被遗忘，据说在低比特率下表现比 aacPlus 更好。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.10 mp3PRO\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				MP3 加 上 SBR 技术诞生的一种产品，但是并没有得到多大推广，更没有进入标准。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.1.11 MP3 Surround\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				让MP3 插 上多声道的翅膀，Fraunhofer 开发的又一种 MP3 升级产品，听说 DivX 6 准备将它作为音频编码。Fraunhofer 一直都在围 绕着 MP3 升级，mp3PRO、MP3 Surround，这些产品都能和传统 MP3 兼容，但是随着层出不穷的新编码，不知道 MP3 还能走多 远。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.2\">\r\n	3.2. DVD系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		说了MPEG，就不能不提这个 MPEG-2 最大受益者 --DVD。当然，这里是指 DVD-Video 和 DVD-Audio，也会涉及一些HD DVD。DVD 的编码都属于应用级的，它们自己并不开发 编码，这一点要和 MPEG 区别开来。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.1 Dolby Digital AC3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				DVD 事实上 的音频编码标准，现在所有的 DVD 都采用它压缩音频，提供了最大 5.1 声道的输出支持，能在有限的空间存储高质的音频。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.2 Dolby Digital Plus\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				下 一代 HD DVD 的音频编码，是 AC3 的升级版本，支持 7.1 甚至更多的声道，码率范围也有大幅提升。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.3 MLP Lossless\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				HD DVD 上 的无损音频编码，同样为 Dolby 公司开发，最高采样能达到 192KHz，也为 DVD-Audio 的音频编码标准。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.4 DTS\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				DTS 最 初是为电影院开发的音频系统，后来才应用于 DVD 中。它是 AC3 的有力竞争者，不过在 DVD 中只有 D9 才能够看到他的身影，虽然广大发烧 友都在鼓吹它的效果超过 AC3，但是测试出来并不如想象中的那么好，特别是高频方面不及 AC3。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.5 DTS-HD\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				下 一代 HD DVD 的音频编码，它和 Dolby Digital Plus 都被指定为强制编码，看来在未来会和 Dolby 平分秋色。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.6 LPCM\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				没有压缩的 PCM 编码，只能存储两声道，但是采样率能够高达 96KHz，是 DVD-Video 中音质最好的一种，当然体积也是最大的。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.7 MPEG Audio\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				主要是 MP2，应用于 PAL 制式的 DVD，压缩率高，支持多声道（MPEG-2 规范都支持多声道）。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.2.8 DSD\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				这个似乎扯远了，不过作为 DVD-Audio 的最大竞争对手 SACD，顺带介绍一下。DSD（Direct Stream Digital）直接比特 流数字，由 Sony 推出，能够避免传统 PCM 编码的弊端，达到非常高的品质。最高采样和 DVD-Audio 一样，192KHz。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.3\">\r\n	3.3. H.26X 系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		\"ITU（International Telecommunication Union）国际电传视讯联盟\"主 导的编码系列，主要应用于实时视频通信领域，如会议电视等。由于现在 MPEG 系列也开始向这个领域进军，所以这两个组织也开始了密切的合作，如最近热 门的 AVC/H.264，就是由 ITU 旗下的\"VCEG（Video Coding Experts Group）视频编码专家组\"和 \"ISO（International Organization for Standardization）国际标准组织\"旗下的 \"MPEG （Moving Pictures Experts Group）运动图象专家组\"联合制作发布的。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.1 H.261\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				H.261 是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各 个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.2 H.263\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				H.263 是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.3 H.263+\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				H.263 的 第二个版本，加入了许多新技术来扩展 H.263 的应用范围。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.4 H.263++\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在 H.263+ 上 增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.5 H.264\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				也 就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO /IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为 H.264标准。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.3.6 3GPP\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				现在通讯领域最热门的话题之一，既然说 了 MPEG 和 ITU，和这两个千丝万缕的 3GPP 应用就不得不提了。3GPP 的视频采用了 MPEG-4 和 H.263 两种编码，可能还 将加入 H.264，音频方面音乐压缩采用 AAC，语音则采用先进的 AMR，另一个 aacPlus 随着 V2 版本的推出，底码率下的效果更加突 出，也有望加入标准。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.4\">\r\n	3.4. Windows Media系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		Microsoft 公司主导 的音频视频编码系列，它的出现主要是为了进行网络视频传输，现在已经向 HDTV 方面进军，开发了 WMV HD 应用。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.1 Microsoft MPEG-4 v1/v2/v3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				最 早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来 才进行了重写。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.2 Windows Media Video 7\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Microsoft 正式开发的 第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效 果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.3 Windows Media Video 8\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在 WMV7 基 础上改进的版本，质量上面进不了不少。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.4 Windows Media Video 9\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				微软的重 头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别 是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.5 Windows Media Video 9 Professional\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				WMV HD 应 用的编码，和 WMV9 兼容，在高比特率上进行了优化，画面非常优秀。（不过几十M的码率能不优秀吗？全是体积换来的。）\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.6 Windows Media Video 9 Advanced Profile\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				随 着 Windows Media Player 10 推出的编码器，能够更进一步控制 WMV9 的质量。但是不能在老版本的 WMP9 上播放，也就 是不兼容老版本的 WMP9，真不知微软在搞什么？\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.7 Windows Media Video 9 Screen\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				静 态屏幕无损压缩编码，质量非常好，压缩率高，只针对如屏幕等变化非常小的环境。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.8 Windows Media Video 9 Image\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				静 态图像压缩编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.9 Windows Media Audio v1/v2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				微软最早的音频编码技 术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.10 Windows Media Audio 7/8/9\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				随 着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.11 Windows Media Audio 9 Professional\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				WMA9 中 出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.12 Windows Media Audio 9 Voice\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				针 对语音的编码，最高 20kbps ，不过和 AMR 相比，效果就太差了。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.4.13 Windows Media Audio 9 Lossless\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				无 损音频编码，可以完美保留CD原质量，是CD备份的不错选择，不过代价是体积过大。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.5\">\r\n	3.5. RealMedia系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		RealNetworks 所 开发的系列编码技术，也是主要用于网络传输，在底码率下表现不错。\r\n	</li>\r\n	<li>\r\n		3.5.1 RealVideo G2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				早 期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.2 RealVideo 8\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				随 着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.3 RealVideo 9\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				RealNetworks 开 发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.4 RealVideo 10\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				在 RealVideo 9 基 础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.5 RealAudio Cook\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				早 期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、 RealAudio 8。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.6 RealAudio Cook Multichannel\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Cook 的 改进版本，增加了5.1声道的支持，应用到了 RealAudio 10 Multichannel 中。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3.5.7 RealAudio Sipro\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				采 用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.8 RealAudio ATRAC3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Sony 公 司开发的 ATRAC3 编码，被 RealNetworks 公司购买过来应用到了 RealAudio 8 中，以弥补 Cook 高码率上的不足。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.9 RealAudio AAC\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				AAC音频编码，用于 RealAudio 10 中。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.10 RealAudio aacPlus\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				aacPlus 音 频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.5.11 RealAudio Lossless\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				无 损音频编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.6\">\r\n	3.6. QuickTime系列\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		QuickTime 并不是一个编码，而是一个多媒体平台，它的上面有众多编码，这里只介绍几个主流的编码器。\r\n	</li>\r\n	<li>\r\n		3.6.1 Sorenson Video 2\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Sorenson Media 公 司开发的编码器，主要用于 QuickTime 4 的视频编码，质量较差。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.6.2 Sorenson Video 3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Sorenson Media 公 司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.6.3 Apple MPEG-4\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Apple 公 司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.6.4 Apple H.264\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Apple 公 司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.6.5 QDesign Music 1\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				QDesign 公 司开发的音频编码器，这个版本现在已经开不到它的身影了。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<p style=\"color:#000000;text-indent:0px;\">\r\n	*3.6.6 QDesign Music 2\r\n</p>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		QDesign Music 的 第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。\r\n	</li>\r\n</ul>\r\n<ul class=\"noindent\">\r\n	<li style=\"color:#000000;text-indent:0px;\">\r\n		3.6.7 Qualcomm PureVoice\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		Qualcomm 公 司开发的语音编码器，质量不错。\r\n	</li>\r\n</ul>\r\n<ul class=\"noindent\">\r\n	<li style=\"color:#000000;text-indent:0px;\">\r\n		3.6.8 Apple MPEG-4 AAC\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		Apple 公司自己开发 的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。\r\n	</li>\r\n</ul>\r\n<ul class=\"noindent\">\r\n	<li style=\"color:#000000;text-indent:0px;\">\r\n		3.6.9 AMR Narrowband\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		AMR 语音编码器，这个版本只支持 AMR-NB。\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		3.6.10 Apple Lossless\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Apple 公司开发的无损音频编码，主要应用于 iTunes 抓取 CD。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"font-weight:bold;font-size:1.8em;color:#707070;font-family:\'Trebuchet MS\', Helvetica, sans-serif;\" id=\"toc_1.3.7\">\r\n	3.7. Ogg系列\r\n</h3>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		Ogg 是 Xiph.org 基 金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为 止 128kbps 码率上最好的编码器。\r\n	</li>\r\n	<li>\r\n		3.7.1 Ogg Theora\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ogg 的视频编码，基于On2 VP3 开发，现在还处于测试阶段。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.7.2 Ogg Vorbis\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ogg 的音频编码， 质量非常优秀，特别是低码率下，支持多声道。最高码率能够达到 500kbps，是 AAC 的有力竞争者。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.7.3 Ogg Speex\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Ogg 的 语音编码，专门针对低码率的语音编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.7.4 Ogg FLAC\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				gg 的无损音频编码。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h3 style=\"font-weight:bold;font-size:1.8em;color:#707070;font-family:\'Trebuchet MS\', Helvetica, sans-serif;\" id=\"toc_1.3.8\">\r\n	3.8. On2 VPX 系列\r\n</h3>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们 就采用了 VP3，VP5，VP6 视频编码。\r\n	</li>\r\n	<li>\r\n		3.8.1 VP3\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				已经作为开放源代码公布，现在是Ogg Theora项目，当然，Theora 的质量可比 VP3 好多了。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.8.2 VP4\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				On2公司当年吹牛全球最好的视频编码，后来证明质量很一般。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.8.3 VP5\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				至今还很神秘，On2并没有放出来，只在 Nullsoft Video 里面见到他的身影。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		3.8.4 VP6\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				从一开始，On2 就把这个编码器提供给大家下载，质量还是不错的。不过最近似乎又关闭了，主页上只有一个解码器。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.8.5 VP7\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				On2 最新的编码器，在 VP6 上有不少进步。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		3.8.6 Flash Video\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传 闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<h2 style=\"font-weight:bold;font-size:2.2em;color:#404040;font-family:\'Trebuchet MS\', Helvetica, sans-serif;\" id=\"toc_1.4\">\r\n	4. MPEG完整介绍\r\n</h2>\r\n<p>\r\n	我这有本书，刘德峰的《多媒体技术基础》，介绍得比较好，感兴趣的可以来看。\r\n</p>\r\n<h2 style=\"font-weight:bold;font-size:2.2em;color:#404040;font-family:\'Trebuchet MS\', Helvetica, sans-serif;\" id=\"toc_1.5\">\r\n	5. 参考文献\r\n</h2>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		<a href=\"http://blogold.chinaunix.net/u/23367/showart_319058.html\">http://blogold.chinaunix.net/u/23367/showart_319058.html</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://zh.wikipedia.org/zh/視訊編解碼器\">http://zh.wikipedia.org/zh/%E8%A6%96%E8%A8%8A%E7%B7%A8%E8%A7%A3%E7%A2%BC%E5%99%A8</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://blog.sina.com.cn/s/blog_4a946a310100drnl.html\">http://blog.sina.com.cn/s/blog_4a946a310100drnl.html</a> \r\n	</li>\r\n</ul>\r\n<h2 style=\"font-weight:bold;font-size:2.2em;color:#404040;font-family:\'Trebuchet MS\', Helvetica, sans-serif;\" id=\"toc_1.6\">\r\n	6. Mp4容器格式相关的BLOG介绍\r\n</h2>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		<a href=\"http://blog.sina.com.cn/s/blog_48f93b530100jz4b.html\">http://blog.sina.com.cn/s/blog_48f93b530100jz4b.html</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://blog.sina.com.cn/s/blog_48f93b530100jz4x.html\">http://blog.sina.com.cn/s/blog_48f93b530100jz4x.html</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://www.52rd.com/Blog/wqyuwss/559/\">http://www.52rd.com/Blog/wqyuwss/559/</a> \r\n	</li>\r\n</ul>\r\n<ul class=\"noindent\">\r\n</ul>','<p>\r\n	1. 多媒体格式分类\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	多媒体的格式包括三种：封装格式、视频编解码、音频编解码。\r\n</p>\r\n<p>\r\n	1.1. 多媒体封装格式(又称容器）\r\n</p>','','2','5','blog','18','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('28','MP4容器格式','1373375185','<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.1\">\r\n	1. 格式解析文章\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		<a href=\"http://blog.csdn.net/zzqhost/article/details/8275518\">MP4容器格式分析1</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://blog.csdn.net/zzqhost/article/details/8275457\">MP4容器格式分析2</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://blog.csdn.net/zzqhost/article/details/8275467\">H264-MP4格式及在MP4文件中提取H264的SPS、PPS及码流</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://www.52rd.com/Blog/wqyuwss/559/\">wqyuwss的专栏</a> \r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.2\">\r\n	2. 资源下载及参考地址\r\n</h2>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		<a href=\"http://mp4ra.org/atoms.html\">Box类型列表</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://www.ftyps.com/\">Ftyps列表</a> \r\n	</li>\r\n	<li>\r\n		<a href=\"http://standards.iso.org/ittf/PubliclyAvailableStandards/index.html\">官方标准文档下载</a> \r\n	</li>\r\n</ul>\r\n<h2 style=\"color:#404040;text-indent:0px;\" id=\"toc_1.3\">\r\n	3. MP4相关的容器格式介绍\r\n</h2>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.1\">\r\n	3.1. MOV\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		MOV即QuickTime影片格式，它是Apple公司开发的一种音频、视频文件格式，用于存储常用数字媒体类型。当选择QuickTime（*.mov）作为\"保存类型\"时，动画将保存为.mov文件。\r\n	</li>\r\n	<li>\r\n		MP4容器格式就是以MOV为基础，然后由那个某某某组织重新定义了一下。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.2\">\r\n	3.2. 3GP\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		3GP是一种3G流媒体的视频编码格式，使用户能够发送大量的数据到移动电话网络，从而明确传输大型文件，如音频，视频和数据网络的手机。3GP是MP4格式的一种简化版本，减少了储存空间和较低的频宽需求，让手机上有限的储存空间可以使用。\r\n	</li>\r\n	<li>\r\n		3GP是MP4格式的一种简化版本，减少了储存空间和较低的频宽需求，让手机上有限的储存空间可以使用。\r\n	</li>\r\n	<li>\r\n		目前3GP档案有两种不相同的标准：\r\n		<ul style=\"margin-left:2em;\">\r\n			<li>\r\n				3GPP（针对GSM手机，扩展名为.3gp）\r\n			</li>\r\n			<li>\r\n				3GPP2（针对CDMA手机，扩展名为.3g2）\r\n			</li>\r\n			<li>\r\n				这两种格式影像方面都采用MPEG-4及H.263，而声音则采用AAC或AMR标准。\r\n			</li>\r\n		</ul>\r\n	</li>\r\n	<li>\r\n		结论：3GP是缩水版的MP4格式，主要应用于3G网络。\r\n	</li>\r\n</ul>\r\n<h3 style=\"color:#707070;text-indent:0px;\" id=\"toc_1.3.3\">\r\n	3.3. M4V\r\n</h3>\r\n<ul style=\"margin-left:2em;color:#000000;text-indent:0px;\">\r\n	<li>\r\n		M4V是一种应用于网络视频点播网站和移动手持设备的视频格式，是MP4格式的一种特殊类型，其后缀常为.MP4或.M4V，其视频编码采用H264，音频编码采用AAC。\r\n	</li>\r\n	<li>\r\n		M4V 是一个标准视频文件格式，由苹果公司创造。此种格式为 iPod 、 iPhone 和 PlayStation Portable 所使用，同时此格式基于 MPEG-4 编码第二版。\r\n	</li>\r\n	<li>\r\n		MP4最早期是一种应用于移动手持设备的格式，作为MP4的特殊类型，M4V是MP4格式高清的代表，应用于移动手持设备，又称为MP4-AVC\r\n	</li>\r\n	<li>\r\n		结论： M4V是MP4的高清版本，是一种特殊类型的MP4格式。\r\n	</li>\r\n</ul>','<p>\r\n	1. 格式解析文章\r\n</p>\r\n<p>\r\n	MP4容器格式分析1\r\n</p>\r\n<p>\r\n	MP4容器格式分析2\r\n</p>\r\n<p>\r\n	H264-MP4格式及在MP4文件中提取H264的SPS、PPS及码流\r\n</p>\r\n<p>\r\n	wqyuwss的专栏\r\n</p>\r\n<p>\r\n	2. 资源下载及参考地址\r\n</p>\r\n<p>\r\n	Box类型列表\r\n</p>\r\n<p>\r\n	Ftyps列表\r\n</p>\r\n<p>\r\n	官方标准文档下载\r\n</p>\r\n<p>\r\n	3. MP4相关的容器格式介绍\r\n</p>\r\n<p>\r\n</p>','','2','5','blog','7','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('29','MIME','1373375207','<h3>1. Content-Type </h3>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li>此内容来源于: <a href=\"http://zh.wikipedia.org/zh/MIME\">维基百科</a> </li>    <li>内容类型（Content-Type），这个头部领域用于指定消息的类型。一般以下面的形式出现。      <ul style=\"margin-left: 2em\">       <li>Content-Type: [type]/[subtype]; parameter </li>     </ul>   </li> </ul>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li>type有下面的形式。      <ul style=\"margin-left: 2em\">       <li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； </li>        <li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据； </li>        <li>Application：用于传输应用程序数据或者二进制数据； </li>        <li>Message：用于包装一个E-mail消息； </li>        <li>Image：用于传输静态图片数据； </li>        <li>Audio：用于传输音频或者音声数据； </li>        <li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。 </li>     </ul>   </li> </ul>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li>subtype      <ul style=\"margin-left: 2em\">       <li>subtype用于指定type的详细形式。 </li>        <li>content-type/subtype配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用<a href=\"http://www.iana.org/\">Internet Assigned Numbers Authority (IANA)</a>作为中心的注册机制来管理这些值。 </li>        <li>常用的subtype值如下所示：          <ul style=\"margin-left: 2em\">           <li>text/plain（纯文本） </li>            <li>text/html（HTML文档） </li>            <li>application/xhtml+xml（XHTML文档） </li>            <li>image/gif（GIF图像） </li>            <li>image/jpeg（JPEG图像）【PHP中为：image/pjpeg】 </li>            <li>image/png（PNG图像）【PHP中为：image/x-png】 </li>            <li>video/mpeg（MPEG动画） </li>            <li>application/octet-stream（任意的二进制数据） </li>            <li>application/pdf（PDF文档） </li>            <li>application/msword（Microsoft Word文件） </li>            <li>application/vnd.wap.xhtml+xml (wap1.0+) </li>            <li>application/xhtml+xml (wap2.0+) </li>            <li>message/rfc822（RFC 822形式） </li>            <li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示） </li>            <li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单） </li>            <li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合） </li>            <li>此外，尚未被接受为正式数据类型的subtype，可以使用x-开始的独立名称（例如application/x-gzip）。vnd-开始的固有名称也可以使用（例：application/vnd.ms-excel）。 </li>         </ul>       </li>     </ul>   </li> </ul>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li>parameter可以用来指定附加的信息      <ul style=\"margin-left: 2em\">       <li>更多情况下是用于指定text/plain和text/htm等的文字编码方式的charset参数。 </li>     </ul>   </li> </ul>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li>MIME根据type制定了默认的subtype，当客户端不能确定消息的subtype的情况下，消息被看作默认的subtype进行处理。      <ul style=\"margin-left: 2em\">       <li>Text默认是text/plain， </li>        <li>Application默认是application/octet-stream </li>        <li>Multipart默认情况下被看作multipart/mixed。 </li>     </ul>   </li> </ul>  <h3>2. 有用的链接 </h3>  <ul style=\"margin-left: 2em; color: #000000; text-indent: 0px\">   <li><a href=\"http://www.iana.org/\">Internet Assigned Numbers Authority (IANA)</a> </li>    <li><a href=\"http://www.iana.org/assignments/media-types\">查询已注册的Mime type</a> </li> </ul>','<p>\r\n	<span><span>内容类型（Content-Type），这个头部领域用于指定消息的类型。一般以下面的形式出现。</span></span> \r\n</p>\r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		Content-Type: [type]/[subtype]; parameter\r\n	</li>\r\n</ul>\r\n<span style=\"line-height:1.5;\"><span>type有下面的形式。</span> \r\n<ul style=\"margin-left:2em;\">\r\n	<li>\r\n		Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；\r\n	</li>\r\n	<li>\r\n		Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；\r\n	</li>\r\n	<li>\r\n		Application：用于传输应用程序数据或者二进制数据；\r\n	</li>\r\n	<li>\r\n		Message：用于包装一个E-mail消息；\r\n	</li>\r\n	<li>\r\n		Image：用于传输静态图片数据；\r\n	</li>\r\n	<li>\r\n		Audio：用于传输音频或者音声数据；\r\n	</li>\r\n	<li>\r\n		Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。\r\n	</li>\r\n</ul>\r\n</span><br />\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<h2 id=\"toc_1.1\" style=\"color:#404040;\">\r\n</h2>\r\n<h2 id=\"toc_1.2\" style=\"color:#404040;\">\r\n</h2>\r\n<p>\r\n	<br />\r\n</p>','','2','5','blog','13','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('32','Miracast及其相似技术名词解释','1373880052','<p>JB 4.2有个独特功能叫Miracast，能将Nexus 4手机的游戏、影视“镜像”电视机或者电视盒上。   <br />谷歌论坛已经确认刚发布的三个亲儿子中，只有Nexus 4具有这项功能。小米则号称不但可以跟安卓传输，还包括苹果产品，但似乎还不支持Miracast。    <br />目前这种将终端信号经由WiFi传输到电视、电视盒的技术有四种：DLNA、AirPlay、Miracast。</p>  <h3>四种技术简介</h3>  <p>   <br /><strong>DLNA：</strong>    <br />DNLA，Digital Living Network Alliance，是索尼、英特尔、微软等发起的一套 PC、移动设备、消费电器之间互联互通的协议。它们的宗旨是“随时随地享受音乐、照片和视频”。安卓系统部分播放器就具备DLNA功能，例如PPTV就有这功能。可以将原来应该在N7屏幕的影片转移到电视屏幕上。前提是你要有能支持DLNA的电视或者电视盒。</p>  <p>   <br /><strong>AirPlay:</strong>    <br />AirPlay 是苹果开发的一种无线技术，可以通过WiFi将iOS 设备上的包括图片、音频、视频通过无线的方式传输到支持AirPlay 设备。售价99美元的Apple TV就具备这样的功能。    <br />AirPlay具备与DLNA所没有的镜像功能，可将iPhone 或iPad 上的画面无线传输到电视上，也就是说你设备显示的是什么，电视屏幕显示就就是什么，而不仅限于图片和视频。你可以拿着iPad 来当做方向盘，然后看着大屏玩游戏。</p>  <p>   <br /><strong>Miracast:</strong>    <br />Miracast是由Wi-Fi联盟于2012年所制定，以Wi-Fi直连为基础的无线显示标准。支持此标准的设备可通过无线方式分享视频画面，例如手机可通过Miracast将影片或照片直接在电视或其他装置播放而无需受到连接线缆长度的影响。与DLNA不同的是，Miracast 也有类似于AirPlay 的镜像功能，可以将手机中屏幕内容直接投放到高清电视屏幕里，这样你也可以通过电视屏幕来玩游戏了。</p>  <p><strong>WiMo（Wireless Mobile Multimedia Transmitting），</strong>是由电信运营商中国移动主导、国内主流家电厂家参与的正在开发的移动终端无线多媒体共享技术。</p>  <p>&#160;</p>  <h3>Air Play</h3>  <h4>场景一：</h4>  <p>朋友们聚会，你去到朋友家里，大家纷纷向你祝贺，你的女儿初临人世，你说，我们来看看我的宝贝吧。然后拿出你的 iPhone 手机，朋友把家里的 Apple TV 和高清电视机打开，使用 iPhone 手机上的 AirPlay Mirroring 的功能将整个 iPhone 手机整个桌面通过 Apple TV 传送到高清电视机，朋友们看到你的 iPhone 图形界面展示在 46 寸的屏幕上，你在 iPhone 上的任何操作朋友们在大电视上无时延看到操作效果。   <br /></p>  <h4>场景二：</h4>  <p>当朋友们谈起赛车游戏，你也许很有心得想演示一番，于是，你打开手机赛车游戏，拿着 iPhone 开始风驰电掣，朋友们兴致勃勃看着大屏幕电视，赛车场人群汹涌掌声如雷（声音通过电视配套的扬声器发出），高楼霓虹灯街景急速后退，大家尽兴而归。</p>  <h4>适用范围</h4>  <p>目前，苹果的官方的操作系统的 AirPlay 解决方案只适用于认证过苹果设备，目前主要是 iPad、iPhone、Apple TV 以及苹果公司授权合作伙伴的设备——例如 Pioneer 以及 Sony 提供支持 AirPlay 的音响。然而，业界还有非苹果直接支持的解决方案，以不同的技术手段实现相类似的功能，主要有 DLNA 联盟、独立解决方案、以及国内的中国移动主导的 WiMo。</p>  <p>&#160;</p>  <h3>DLNA</h3>  <p><strong>DLNA 是什么？</strong>这里简单地介绍一下，DLNA(Digital Living Network Alliance）数字生活网络联盟由微软、英特尔、三星、诺基亚、高通等业界领袖组成，而苹果据说曾经是DLNA联盟的成员，后来退出了自立门户。</p>  <p> AirPlay 无疑会成功，并增加了苹果设备的无穷魅力，但是，DLNA 具有更广泛的开放的产业联盟，和更成熟的商业实现基础。DLNA的核心网络协议为 UPnP（Universal Plug and Play），UPnP 定义了家庭本地网络内各种设备的角色分工以及彼此发现彼此交互的过程，只要遵循该标准，设备可以自由接入。现有大量电子产品支持该标准（一般说来，支持DLNA的设备贴有DLNA-certified认证的标签，DLNA支持的产品可以从这个网站查询获知），三星、LG 等厂家的高端液晶电视机、华为实现的家庭无线及娱乐网关、微软的 XBox Kinect 360、以及 Google TV 许多设备都内置 DLNA 的模块，或者实现成 DMP，或者实现成 DMR、甚至 DMC（DMP、DMR、DMC 是 DLNA 设备的分类表述，若不打算深究可忽略此信息），广为电子达人熟悉的 XMBC 家庭娱乐解决方案以及由&#160; Windows 7 PC 桌面电脑 + XBox kinect 360 + 高清电视机组成的微软的家庭娱乐方案中，均使用了 DLNA 技术。</p>  <p><strong>移动解决方案</strong>甚至苹果的应用商城上面也有许多第三方实现的 DLNA 软件，例如，AirPlayit、iMediaShare/iMediaSuite、AirAV 以及久负盛名的AirVideo 等等，这些软件与 iOS 上的 AirPlay 两者之间有非常微妙的关系，功能上可以替代部分的 AirPlay，技术方案却迥异。究其原因，一方面由于苹果 iOS 上的 AirPlay 开发接口的软件授权限制，另一方面是同时兼容于 iOS 与 Google Android 两个平台的需要。（一个有趣的事情是这类软件还有一些让人很惊喜的实用功能：作为多媒体访问的代理，甚至实现视频格式的实时转码。比如说，对于 iOS 不支持的视频格式数据流，经过 Air Video 服务器端实时转换，能在 iPad 上显示播放。）</p>  <p>&#160;</p>  <h3>Miracast & Wi-Fi Display</h3>  <p>技术简介Wi-Fi Display，手机-电视-显示器将可以实现无线连接。该标准由WiFi无线产业联盟制定，现在还在测试中，技术可以压缩3D视频，从而通过Wi-Fi传输。3D视频很耗带宽，如果不压缩就会迟滞，Wi-Fi Display技术可以将延迟时间降到百分之一毫秒以下。</p>  <p>Miracast实际上就是WiFi联盟（WiFi Alliance）对支持WiFi Display功能的设备的认证名称（该认证项目已经在2012年9月正式启动）。而通过Miracast认证的设备，便可提供简化发现和设置，实现设备间高速传输视频。   <br /><strong>主要特色</strong><strong>·</strong>Wi-Fi Display让使用者在不需要连接线情况下享受高画质影像显示效果。    <br /><strong>·</strong>支援one source-to-one sink。    <br /><strong>·</strong>将室内操作的单一传输装置作为链接网络的last hop，进行影像无线显示。    <br /><strong>·</strong>两个装置分别担任‘Server (Source)-Push’和‘Client (Sink)-Pull’的互动模式。[url=http://baike.baidu.com/picview/6396173/6499177/0/f29faa8f3e625882f01f3680.html][/url] </p>  <p><strong>支持Wi-Fi Display的主要产品</strong>目前支持MWi-Fi Display的发送端设备主要有：oppo find 5、LG: F180L、F200L、LS970、F180S、F180K、F200S、200K;NEC CASIO: N-03E;Samsung: GT-I9300、GT-I9300Z;小米2;小米2S;Nubia Z5;callbar小雨滴4等    <br />支持Wi-Fi Display的接收端设备主要有：小技PTV、WiPlug（中文名：推）、多笑金箍棒、小米盒子等</p>','','','2','7','blog','29','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('30','Git添加远程仓库','1373861028','<p>\r\n	添加远程仓库主要有以下三种写法,如下:\r\n</p>\r\n<p>\r\n	<span style=\"color:#333333;font-family:Arial, Helvetica, sans-serif;line-height:20px;background-color:#FFFFFF;\">git remote add origin ssh://git@hostname/helloworld.git</span><br />\r\n<span style=\"color:#333333;font-family:Arial, Helvetica, sans-serif;line-height:20px;background-color:#FFFFFF;\">git remote add origin ssh://git@192.168.14.70/helloworld.git</span><br />\r\n<span style=\"color:#333333;font-family:Arial, Helvetica, sans-serif;line-height:20px;background-color:#FFFFFF;\">git remote add origin git@192.168.14.70:helloworld.git</span>\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	可以参考我的博客:\r\n</p>\r\n<p>\r\n	　　<a href=\"http://blog.csdn.net/zzqhost/article/details/9233819\">http://blog.csdn.net/zzqhost/article/details/9233819</a>\r\n</p>','','','2','6','blog','9','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('31','Android Wi-Fi Display（Miracast）介绍','1373873173','<h3>\r\n	Android Wi-Fi Display（Miracast）介绍\r\n</h3>\r\n<p>\r\n	&nbsp;\r\n</p>\r\n<p>\r\n	2012年11月中旬，Google发布了Android 4.2。虽然它和Android 4.1同属Jelly Bean系列，但却添加了很多新的功能。其中，在显示部分，Android 4.2在Project Butter基础上再接再厉，新增了对Wi-Fi Display功能的支持。由此也导致整个显示架构发生了较大的变化。\r\n</p>\r\n<p>\r\n	本文首先介绍Wi-Fi Display的背景知识，然后再结合代码对Android 4.2中Wi-Fi Display的实现进行介绍。\r\n</p>\r\n<h4>\r\n	<a name=\"t1\"></a>一 背景知识介绍\r\n</h4>\r\n<p>\r\n	Wi-Fi Display经常和Miracast联系在一起。实际上，Miracast是Wi-Fi联盟（Wi-Fi Alliance）对支持Wi-Fi Display功能的设备的认证名称。通过Miracast认证的设备将在最大程度内保持对Wi-Fi Display功能的支持和兼容。由此可知，Miracast考察的就是Wi-Fi Display（本文后续将不再区分Miracast和Wi-Fi Display）。而Wi-Fi Display的核心功能就是让设备之间通过Wi-Fi无线网络来分享视音频数据。以一个简单的应用场景为例：有了Wi-Fi Display后，手机和电视机之间可以直接借助Wi-Fi，而无需硬连线（如HDMI）就可将手机中的视频投递到TV上去显示<a href=\"http://write.blog.csdn.net/postedit#_ftn1\" name=\"_ftnref1_1822\">[</a>①<a href=\"http://write.blog.csdn.net/postedit#_ftn1\" name=\"_ftnref1_1822\">]</a>。以目前智能设备的发展趋势来看，Wi-Fi Display极有可能在较短时间内帮助我们真正实现多屏互动。\r\n</p>\r\n<p>\r\n	从技术角度来说，Wi-Fi Display并非另起炉灶，而是充分利用了现有的Wi-Fi技术。图1所示为Wi-Fi Display中使用的其他Wi-Fi技术项。\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478712_8403.png\" />\r\n</p>\r\n<p>\r\n	图1 Miracast的支撑体系结构\r\n</p>\r\n<p>\r\n	由图1可知，Miracast依赖的Wi-Fi技术项[②]有：\r\n</p>\r\n<ul>\r\n	<li>\r\n		Wi-Fi Direct，也就是Wi-Fi P2P。它支持在没有AP（Access Point）的情况下，两个Wi-Fi设备直连并通信。\r\n	</li>\r\n	<li>\r\n		Wi-Fi Protected Setup：用于帮助用户自动配置Wi-Fi网络、添加Wi-Fi设备等。\r\n	</li>\r\n	<li>\r\n		11n/WMM/WPA2：其中，11n就是802.11n协议，它将11a和11g提供的Wi-Fi传输速率从56Mbps提升到300甚至600Mbps。WMM是Wi-Fi Multimedia的缩写，是一种针对实时视音频数据的QoS服务。而WPA2意为Wi-Fi Protected Acess第二版，主要用来给传输的数据进行加密保护。\r\n	</li>\r\n</ul>\r\n<p>\r\n	上述的Wi-Fi技术中，绝大部分功能由硬件厂商实现。而在Android中，对Miracast来说最重要的是两个基础技术：\r\n</p>\r\n<ul>\r\n	<li>\r\n		Wi-Fi Direct：该功能由Android中的WifiP2pService来管理和控制。\r\n	</li>\r\n	<li>\r\n		Wi-Fi Multimedia：为了支持Miracast，Android 4.2对MultiMedia系统也进行了修改。\r\n	</li>\r\n</ul>\r\n<p>\r\n	下边我们对Miracast几个重要知识点进行介绍，首先是拓扑结构和视音频格式方面的内容。\r\n</p>\r\n<p>\r\n	Miracast一个重要功能就是支持Wi-Fi Direct。但它也考虑了无线网络环境中存在AP设备的情况下，设备之间的互联问题。读者可参考如图2所示的四种拓扑结构。\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478739_2291.png\" />\r\n</p>\r\n<p>\r\n	图2&nbsp; Miracast的四种拓扑结构\r\n</p>\r\n<p>\r\n	图2所示内容比较简单，此处就不再详述。另外，在Wi-Fi Display规范中，还存在着Source将Video和Audio内容分别传送给不同Render Device的情况。<a name=\"OLE_LINK6\"></a><a name=\"OLE_LINK5\"></a>感兴趣的读者可参考Wi-Fi Display技术规范。\r\n</p>\r\n<p>\r\n	另外，Miracast对所支持的视音频格式也进行了规定，如表1所示。\r\n</p>\r\n<p>\r\n	表1&nbsp; Miracast 视音频格式支持\r\n</p>\r\n<p>\r\n	分辨率\r\n</p>\r\n<p>\r\n	17种 CEA格式，分辨率从640*480到1920*1080，帧率从24到60\r\n</p>\r\n<p>\r\n	29种VESA格式，分辨率从800*600到1920*1200，帧率从30到60\r\n</p>\r\n<p>\r\n	12种手持设备格式，分辨率从640*360到960*540，帧率从30到60\r\n</p>\r\n<p>\r\n	视频\r\n</p>\r\n<p>\r\n	<a name=\"OLE_LINK2\"></a><a name=\"OLE_LINK1\"></a>H.264高清\r\n</p>\r\n<p>\r\n	音频\r\n</p>\r\n<p>\r\n	必选：LPCM 16bits，48kHz采样率，双声道\r\n</p>\r\n<p>\r\n	可选：\r\n</p>\r\n<p>\r\n	LPCM 16bits，44.1kHz采样率，双声道\r\n</p>\r\n<p>\r\n	Advanced Audio coding\r\n</p>\r\n<p>\r\n	Dolby Advanced Codec 3\r\n</p>\r\n<p>\r\n	最后，我们简单介绍一下Miracast的大体工作流程。Miracast以session为单位来管理两个设备之间的交互的工作，主要步骤包括（按顺序）：\r\n</p>\r\n<ul>\r\n	<li>\r\n		Device Discovery：通过Wi-Fi P2P来查找附近的支持Wi-Fi P2P的设备。\r\n	</li>\r\n	<li>\r\n		Device Selection：当设备A发现设备B后，A设备需要提示用户。用户可根据需要选择是否和设备B配对。\r\n	</li>\r\n	<li>\r\n		Connection Setup：Source和Display设备之间通过Wi-Fi P2P建立连接。根据Wi-Fi Direct技术规范，这个步骤包括建立一个Group Owner和一个Client。此后，这两个设备将建立一个TCP连接，同时一个用于RTSP协议的端口将被创建用于后续的Session管理和控制工作。\r\n	</li>\r\n	<li>\r\n		Capability Negotiation：在正式传输视音频数据前，Source和Display设备需要交换一些Miracast参数信息，例如双方所支持的视音频格式等。二者协商成功后，才能继续后面的流程。\r\n	</li>\r\n	<li>\r\n		Session Establishment and streaming：上一步工作完成后，Source和Display设备将建立一个Miracast Session。而后就可以开始传输视音频数据。Source端的视音频数据将<a name=\"OLE_LINK4\"></a><a name=\"OLE_LINK3\"></a>经由MPEG2TS编码后通过RTP协议传给Display设备。Display设备将解码收到的数据，并最终显示出来。\r\n	</li>\r\n	<li>\r\n		User Input back channel setup：这是一个可选步骤。主要用于在传输过程中处理用户发起的一些控制操作。这些控制数据将通过TCP在Source和Display设备之间传递。\r\n	</li>\r\n	<li>\r\n		Payload Control：传输过程中，设备可根据无线信号的强弱，甚至设备的电量状况来动态调整传输数据和格式。可调整的内容包括压缩率，视音频格式，分辨率等内容。\r\n	</li>\r\n	<li>\r\n		Session teardown：停止整个Session。\r\n	</li>\r\n</ul>\r\n<p>\r\n	通过对上面背景知识的介绍，读者可以发现：\r\n</p>\r\n<ul>\r\n	<li>\r\n		Miracast本质就是一个基于Wi-Fi的网络应用。这个应用包括服务端和客户端。\r\n	</li>\r\n	<li>\r\n		服务端和客户端必须支持RTP/RTSP等网络协议和相应的编解码技术。\r\n	</li>\r\n</ul>\r\n<h4>\r\n	<a name=\"t2\"></a>二&nbsp; Android 4.2 Miracast功能实现介绍\r\n</h4>\r\n<p>\r\n	Miracast的Android实现涉及到系统的多个模块，包括：\r\n</p>\r\n<ul>\r\n	<li>\r\n		MediaPlayerService及相关模块：原因很明显，因为Miracast本身就牵扯到RTP/RTSP及相应的编解码技术。\r\n	</li>\r\n	<li>\r\n		SurfaceFlinger及相关模块：SurfaceFlinger的作用是将各层UI数据混屏并投递到显示设备中去显示。现在，SurfaceFlinger将支持多个显示设备。而支持Miracast的远端设备也做为一个独立的显示设备存在于系统中。\r\n	</li>\r\n	<li>\r\n		WindowManagerService及相关模块：WindowManagerService用于管理系统中各个UI层的位置和属性。由于并非所有的UI层都会通过Miracast投递到远端设备上。例如手机中的视频可投递到远端设备上去显示，但假如在播放过程中，突然弹出一个密码输入框（可能是某个后台应用程序发起的），则这个密码输入框就不能投递到远端设备上去显示。所以，WindowManagerService也需要修改以适应Miracast的需要。\r\n	</li>\r\n	<li>\r\n		DisplayManagerService及相关模块：DisplayManagerService服务是Android 4.2新增的，用于管理系统中所有的Display设备。\r\n	</li>\r\n</ul>\r\n<p>\r\n	由于篇幅原因，本文将重点关注SurfaceFlinger和DisplayManagerService以及Miracast的动态工作流程。\r\n</p>\r\n<p>\r\n	<a name=\"t3\"></a>2.1&nbsp; SurfaceFlinger对Miracast的支持\r\n</p>\r\n<p>\r\n	相比前面的版本，Android 4.2中SurfaceFlinger的最大变化就是增加了一个名为DisplayDevice的抽象层。相关结构如图3所示：\r\n</p>\r\n<p>\r\n	<img height=\"389\" alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478758_9825.png\" width=\"739\" />\r\n</p>\r\n<p>\r\n	图3&nbsp; SurfaceFlinger家族类图\r\n</p>\r\n<p>\r\n	由图3可知：\r\n</p>\r\n<ul>\r\n	<li>\r\n		Surface系统定义了一个DisplayType的枚举，其中有代表手机屏幕的DISPLAY_PRIMARY和代表HDMI等外接设备的DISPLAY_EXTERNAL。比较有意思的是，作为Wi-Fi Display，它的设备类型是DISPLAY_VIRTUAL。\r\n	</li>\r\n	<li>\r\n		再来看SurfaceFlinger类，其内部有一个名为mDisplays的变量，它保存了系统中当前所有的显示设备（DisplayDevice）。另外，SurfaceFlinger通过mCurrentState和mDrawingState来控制显示层的状态。其中，mDrawingState用来控制当前正在绘制的显示层的状态，mCurrentState表示当前所有显示层的状态。有这两种State显示层的原因是不论是Miracast还是HDMI设备，其在系统中存在的时间是不确定的。例如用户可以随时选择连接一个Miracast显示设备。为了不破坏当前正在显示的内容，这个新显示设备的一些信息将保存到CurrentState中。等到SurfaceFlinger下次混屏前再集中处理。\r\n	</li>\r\n	<li>\r\n		mCurrentState和mDrawingState的类型都是SurfaceFlinger的内部类State。由图3可知，State首先通过layerSortedByZ变量保存了一个按Z轴排序的显示层数组（在Android中，显示层的基类是LayerBase），另外还通过displays变量保存了每个显示层对应的DisplayDeviceState。\r\n	</li>\r\n	<li>\r\n		DisplayDeviceState的作用是保存对应显示层的DisplayDevice的属性以及一个ISurfaceTexure接口。这个接口最终将传递给DisplayDevice。\r\n	</li>\r\n	<li>\r\n		DisplayDevice代表显示设备，它有两个重要的变量，一个是mFrameBufferSurface和mNativeWindow。mFrameBufferSurace是FrameBufferSurface类型，当显示设备不属于VIRTUAL类型的话，则该变量不为空。对于Miracast来说，显示数据是通过网络传递给真正的显示设备的，所有在Source端的SurfaceFlinger来说，就不存在FrameBuffer。故当设备为VIRTUAL时，其对应的mFrameBufferSurface就为空。而ANativeWindow是Android显示系统的老员工了。该结构体在多媒体的视频I/O、OpenGL ES等地方用得较多。而在普通的UI绘制中，ISurfaceTexture接口用得较多。不过早在Android 2.3，Google开发人员就通过函数指针将ANativeWindow的各项操作和ISurfaceTexture接口统一起来。\r\n	</li>\r\n</ul>\r\n<p>\r\n	作为VIRTUAL的Miracast设备是如何通过DisplayDevice这一层抽象来加入到Surface系统中来的呢？下面这段代码对理解DisplayDevice的抽象作用极为重要。如图4所示。\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478788_3356.png\" />\r\n</p>\r\n<p>\r\n	图4&nbsp; SurfaceFlinger代码片段\r\n</p>\r\n<p>\r\n	由图4代码可知：\r\n</p>\r\n<ul>\r\n	<li>\r\n		对于非Virtual设备，DisplayDevice的FrameBufferSurface不为空。而且SurfaceTextureClient的构造参数来自于FrameBufferSurface的getBufferQueue函数。\r\n	</li>\r\n	<li>\r\n		如果是Virtual设备，SurfaceTextureClient直接使用了State信息中携带的surface变量。\r\n	</li>\r\n</ul>\r\n<p>\r\n	凭着上面这两点不同，我们可以推测出如图5所示的DisplayDevice的作用\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478805_4074.png\" />\r\n</p>\r\n<p>\r\n	图5&nbsp; DisplayDevice的隔离示意图\r\n</p>\r\n<p>\r\n	最后再来看一下SurfaceFlinger中混屏操作的实现，代码如图6所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478824_6904.png\" />\r\n</p>\r\n<p>\r\n	图6&nbsp; SurfaceFilnger的混屏操作\r\n</p>\r\n<p>\r\n	由图5可知，SurfaceFlinger将遍历系统中所有的DisplayDevice来完成各自的混屏工作。\r\n</p>\r\n<h5>\r\n	<a name=\"t4\"></a>2.2&nbsp; Framework对Miracast的支持\r\n</h5>\r\n<p>\r\n	为了彻底解决多显示设备的问题，Android 4.2干脆在Framework中新增了一个名为DisplayManagerService的服务，用来统一管理系统中的显示设备。DisplayManagerService和系统其它几个服务都有交互。整体结构如图7所示。\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478840_5925.png\" />\r\n</p>\r\n<p>\r\n	图7&nbsp; DisplayManagerService及相关类图\r\n</p>\r\n<p>\r\n	由图7可知：\r\n</p>\r\n<ul>\r\n	<li>\r\n		DisplayManagerService主要实现了IDisplayManager接口。这个接口的大部分函数都和Wi-Fi Display操作相关。\r\n	</li>\r\n	<li>\r\n		另外，DisplayManagerService和WindowManagerService交互紧密。因为WindowManagerService管理系统所有UI显示，包括属性，Z轴位置等等。而且，WindowManagerService是系统内部和SurfaceFlinger交互的重要通道。\r\n	</li>\r\n	<li>\r\n		DisplayManagerService通过mDisplayAdapters来和DisplayDevice交互。每一个DisplayDevice都对应有一个DisplayAdapter。\r\n	</li>\r\n	<li>\r\n		系统定义了四种DisplayAdapter。HeadlessDisplayAdapter和OverlayDisplayAdapter针对的都是Fake设备。其中OverlayDisplay用于帮助开发者模拟多屏幕之用。LocalDisplayAdapter代表主屏幕，而WifiDisplayAdapter代表Wi-Fi Display。\r\n	</li>\r\n</ul>\r\n<h5>\r\n	<a name=\"t5\"></a>2.3&nbsp; Android中Miracast动态工作流程介绍\r\n</h5>\r\n<p>\r\n	当用户从Settings程序中选择开启Miracast并找到匹配的Device后<a href=\"http://write.blog.csdn.net/postedit#_ftn3\" name=\"_ftnref3_1822\">[③]</a>，系统将通过WifiDisplayController的requestConnect函数向匹配设备发起连接。代码如图8所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478857_7139.png\" />\r\n</p>\r\n<p>\r\n	图8&nbsp; requestConnect函数实现\r\n</p>\r\n<p>\r\n	图8中，最终将调用connect函数去连接指定的设备。connect函数比较中，其中最重要的是updateConnection函数，我们抽取其中部分代码来看，如图9所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478872_3803.png\" />\r\n</p>\r\n<p>\r\n	图9&nbsp; updateConnection函数片段\r\n</p>\r\n<p>\r\n	在图8所示的代码中，系统创建了一个RemoteDisplay，并在这个Display上监听（listen）。从注释中可知，该RemoteDisplay就是和远端Device交互的RTP/RTSP通道。而且，一旦有远端Device连接上，还会通过onDisplayConnected返回一个Surface对象。\r\n</p>\r\n<p>\r\n	根据前面对SurfaceFlinger的介绍，读者可以猜测出Miracast的重头好戏就在RemoteDisplay以及它返回的这个Surface上了。\r\n</p>\r\n<p>\r\n	确实如此，RemoteDisplay将调用MediaPlayerService的listenForRemoteDisplay函数，最终会得到一个Native的RemoteDisplay对象。相关类图如图10所示。\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478888_7208.png\" />\r\n</p>\r\n<p>\r\n	图10&nbsp; RemoteDisplay类图\r\n</p>\r\n<p>\r\n	由图10可知，RemoteDisplay有三个重要成员变量：\r\n</p>\r\n<ul>\r\n	<li>\r\n		mLooper，指向一个ALooper对象。这表明RemoteDisplay是一个基于消息派发和处理的系统。\r\n	</li>\r\n	<li>\r\n		mNetSession指向一个ANetWorkSession对象。从它的API来看，ANetworkSession提供大部分的网络操作。\r\n	</li>\r\n	<li>\r\n		mSource指向一个WifiDisplaySource对象。它从AHandler派生，故它就是mLooper中消息的处理者。注意，图中的M1、M3、M5等都是Wi-Fi Display技术规范中指定的消息名。\r\n	</li>\r\n</ul>\r\n<p>\r\n	RemoteDisplay构造函数中，WifiDisplaySource的start函数将被调用。如此，一个类型为kWhatStart的消息被加到消息队列中。该消息最终被WifiDisplaySource处理，结果是一个RTSPServer被创建。代码如图11所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478903_7919.png\" />\r\n</p>\r\n<p>\r\n	图11&nbsp; kWhatStart消息的处理结果\r\n</p>\r\n<p>\r\n	以后，客户端发送的数据都将通过类型为kWhatRTSPNotify的消息加入到系统中来。而这个消息的处理核心在onReceiveClientData函数中，它囊括了设备之间网络交互的所有细节。其核心代码如图12所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478917_9353.png\" />\r\n</p>\r\n<p>\r\n	图12&nbsp; onReceiveClientData核心代码示意\r\n</p>\r\n<p>\r\n	图12的内容较多，建议读者根据需要自行研究。\r\n</p>\r\n<p>\r\n	根据前面的背景知识介绍，设备之间的交互将由Session来管理。在代码中，Session的概念由WifiSource的内部类PlaybackSession来表示。先来看和其相关的类图结构，如图13所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478932_9334.png\" />\r\n</p>\r\n<p>\r\n	图13&nbsp; PlaybackSession及相关类图\r\n</p>\r\n<p>\r\n	由图13可知：\r\n</p>\r\n<ul>\r\n	<li>\r\n		PlaybackSession及其内部类Track都从AHandler派生。故它们的工作也依赖于消息循环和处理。Track代表视频流或音频流。\r\n	</li>\r\n	<li>\r\n		Track内部通过mMediaPull变量指向一个MediaPull对象。而MediaPull对象则保存了一个MediaSource对象。在PlaybackSession中，此MediaSource的真正类型为SurfaceMediaSource。它表明该Media的源来自Surface。\r\n	</li>\r\n	<li>\r\n		BufferQueue从ISurfaceTexure中派生，根据前面对SurfaceFlinger的介绍，它就是SurfaceFlinger代码示例中代表虚拟设备的State的surface变量。\r\n	</li>\r\n</ul>\r\n<p>\r\n	当双方设备准备就绪后，MediaPull会通过kWhatPull消息处理不断调用MediaSource的read函数。在SurfaceMediaSource实现的read函数中，来自SurfaceFlinger的混屏后的数据经由BufferQueue传递到MediaPull中。代码如图14所示：\r\n</p>\r\n<p>\r\n	<img alt=\"\" src=\"http://img.my.csdn.net/uploads/201301/06/1357478945_6837.png\" />\r\n</p>\r\n<p>\r\n	图14&nbsp; MediaPull和SurfaceMediaSource的代码示意\r\n</p>\r\n<p>\r\n	从图13可知：\r\n</p>\r\n<ul>\r\n	<li>\r\n		左图中，MediaPull通过kWhatPull消息不断调用MediaSource的read函数。\r\n	</li>\r\n	<li>\r\n		右图中，SurfaceMediaSource的read函数由通过mBufferQueue来读取数据。\r\n	</li>\r\n</ul>\r\n<p>\r\n	那么mBufferQueue的数据来自什么地方呢？对，正是来自图4的SurfaceFlinger。\r\n</p>\r\n<p>\r\n	当然，PlaybackSession拿到这些数据后还需要做编码，然后才能发送给远端设备。由于篇幅关系，本文就不再讨论这些问题了。\r\n</p>\r\n<h4>\r\n	<a name=\"t6\"></a>三总结\r\n</h4>\r\n<p>\r\n	本文对Miracast的背景知识以及Android系统中Miracast的实现进行了一番简单介绍。从笔者个人角度来看，有以下几个点值得感兴趣的读者注意：\r\n</p>\r\n<ul>\r\n	<li>\r\n		一定要结合Wi-Fi的相关协议去理解Miracast。重点关注的协议包括Wi-Fi P2p和WMM。\r\n	</li>\r\n	<li>\r\n		Android Miracast的实现中，需要重点理解SurfaceFlinger和RemoteDisplay模块。这部分的实现不仅代码量大，而且类之间，以及线程之间关系复杂。\r\n	</li>\r\n	<li>\r\n		其他需要注意的点就是DisplayManagerService及相关模块。这部分内容在SDK中有相关API。应用开发者应关注这些新API是否能帮助自己开发出更有新意的应用程序。\r\n	</li>\r\n</ul>\r\n<p>\r\n	另外，Android的进化速度非常快，尤其在几个重要的功能点上。作者在此也希望国内的手机厂商或那些感兴趣的移动互联网厂商能真正投入力量做一些更有深度和价值的研发工作。\r\n</p>','','','2','1','blog','32','1','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('33','自我介绍','1373891319','<p>\r\n	我，张志强，一个普通的Coder，由于对IT技术的痴迷，一直流连于各种技术的海洋中。\r\n</p>\r\n<p>\r\n	精通C /C++, 设计模式，目前从事Android平台的开发。\r\n</p>\r\n<p>\r\n	由于某一段时间会痴迷一种技术，所以会的东西很杂，目前正在精心构建自己的博客。\r\n</p>\r\n<p>\r\n	欢迎大家联系我：\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; QQ：40772568\r\n</p>\r\n<p>\r\n	&nbsp; &nbsp; Email：zzqhost@163.com\r\n</p>','','','1','-1','page','0','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('35','WiFI Display介绍','1373962064','<p>WiFI Display（WFD）是WiFI Alliance 开发出的一种规范，使多媒体设备之间建立和维持一个基于WiFi的连接，并且利用这个连接推进视频/音频的在目标设备的呈现播放。</p>  <p>以下是原话</p>  <p>The Wi-Fi Alliance is developing a “Wi-Fi Display Specification” to enable and</p>  <p>sustain a secure connection between multimedia devices, based on Wi-Fi, to </p>  <p>facilitate audio/video rendering</p>  <h3>Wifi display的一些名詞</h3>  <h4>1.Source :</h4>  <p>&#160;&#160; A device that is capable of transmitting multimedia content</p>  <p>&#160;&#160;&#160; 能提供多媒体内容传输的设备</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/07164c0b38714d4f9bd4d25cc47a9b2a20130716080735.png\"><img title=\"20130201091759389\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"149\" alt=\"20130201091759389\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/d8d41afc6943b7c77d960c6368337a2a20130716080735.png\" width=\"438\" border=\"0\" /></a> </p>  <h4>2.Sink :</h4>  <p>&#160;&#160; A device that is capable of receiving and rendering multimedia content</p>  <p>&#160;&#160;&#160; 能接受多媒体内容并将其呈现的设备</p>  <h4>3.Session:</h4>  <p>一个WFD在传输和接收设备之间连接</p>  <h4>4.TDLS:</h4>  <p>一项802.11协议，在两个连接到同一个Ap的客户端设备之间建立的直接连接，不懂的可以看图</p>  <p>Tunneled Direct Link Setup. An 802.11 protocol to setup a direct Wi-Fi </p>  <p>link between two peer client devices (STAs) that are members of the same BSS</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/0a8104e24aa611e4c7ffd8cc6ce7c1e320130716080736.jpg\"><img title=\"20130201091759410\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"369\" alt=\"20130201091759410\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/5a10dfce4b295083da4b2aa1bd769c9520130716080736.jpg\" width=\"485\" border=\"0\" /></a> </p>  <h4>5.wifi direct:</h4>  <p>&#160;&#160; 设备无需通过无线路由器即可相互连接的技术，需要一台设备作为组织者建立一个类似ap功能的网络，其他设备可以搜索到并用wifi连接上</p>  <h3>WFD原理与流程</h3>  <p>还是用现有的图来说明其基本的过程吧</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/a7448258f2f3e56925d29e163f12b14a20130716081422.jpg\"><img title=\"20130201091800889\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"700\" alt=\"20130201091800889\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/a1e952d8f24fbb58a9622d51be5df9de20130716081422.jpg\" width=\"666\" border=\"0\" /></a> </p>  <h4>WFD连接基础</h4>  <p>WFD建立在wifi p2p连接基础上的，支持以下两种连接方式</p>  <p>-wifi direct:（必须支持）</p>  <p>&#160;&#160; 设备无需通过无线路由器即可相互连接的技术，需要一台设备作为组织者建立一个类似ap功能的网络，其他设备可以搜索到并用wifi连接上</p>  <p>-TDLS:（可选）</p>  <p>&#160;&#160; 2台wifi设备连接在同一个Ap上，它们可以直接建立一个点对点的通道实现数据传输</p>  <h4>WFD建立的11个过程</h4>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/db54da6758c247d7f92565a003b0e7a220130716080738.png\"><img title=\"20130201091800904\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"317\" alt=\"20130201091800904\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/8c5097fec9a8d40451bb4489e038d63120130716080738.png\" width=\"578\" border=\"0\" /></a> </p>  <h5>1.Device Discovery</h5>  <p>wfd设备之间的搜索探测功能，使用现有的wifi p2p技术为基础，并在wifi信标、探测信号中加入了wfd特有格式的探测信号</p>  <h5>2.Service discovery</h5>  <p>此功能是可选功能，也是建立在wifi p2p原有的servicediscovery基础上，并加入wfd特有格式的请求和回应命令</p>  <h5>3.Device selection</h5>  <p>用户选择一个需要连接的设备</p>  <p>Wifi-direct 连接的强制和默认的，TDLS可选</p>  <p>若有2个sink，一级和二级sink，wifi p2p组织者必须是source</p>  <h5>4.Wifi connection setup</h5>  <p>使用wifi direct和tdls技术，建立wfd基础线路</p>  <p>将设备建立TCP连接，并创建一个控制端口来建立和维护session，该端口跑的协议是RTSP</p>  <h5>5.Display capability negotiation</h5>  <p>参数协定，决定需要使用的最佳参数，包括音视频解码率，分辨率，信道负载等等</p>  <p>若有一级和二级sink存在，都需要单独设定</p>  <p>过程和命令如下图</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/308f0dc3a0fe6bdd1a3b9c9344f25b7820130716080739.png\"><img title=\"20130201091801331\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"657\" alt=\"20130201091801331\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/94ae6b2c57cdc917cc2185f9e633422b20130716080739.png\" width=\"430\" border=\"0\" /></a> </p>  <h5>6.UIBC setup</h5>  <p>即user input back channel，用户输入反向通道，此功能是可选的。</p>  <p>有两种类型</p>  <p>&#160;&#160;&#160; generic：硬件无关型，如鼠标点击，按键点击、touch点击、放大缩小等</p>  <p>&#160;&#160;&#160; H<a href=\"http://www.honhei.com/\">IDC</a>人机接口设备控制：包括红外线、USB、蓝牙、WIFI、游戏杆、遥控器等</p>  <h5>7.Link content protection</h5>  <p>建立内容保护机制，可选功能</p>  <p>采用的是HDCP2.0安全协议，需要在数据流传输前建立</p>  <h5>8.WFD Session setup</h5>  <p>WFD核心步骤，必须在能力协定的基础上建立</p>  <p>建立过程使用RTSP通信，具体见下图</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/777b34d297d62b3b048a49d2506e335420130716080740.png\"><img title=\"20130201091801697\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"953\" alt=\"20130201091801697\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/d59ce454cb4a156aa259379dd9e1fce820130716080740.png\" width=\"469\" border=\"0\" /></a> </p>  <h5>9.AV Streaming</h5>  <p>先将Audio和video多路复用成一个MPEG2传输流</p>  <p>在传输流头部用MPEG2-TS格式打包，并封装RTP、UDP、IP报头如下图</p>  <p><a href=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/815d4302123cf077edf57f1e95732c0520130716081423.png\"><img title=\"20130201091801318\" style=\"border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px\" height=\"581\" alt=\"20130201091801318\" src=\"http://ftp105557.host185.web522.com/content/uploadfile/201307/bc847f6d5e1d3e9200d7e0580a66def420130716081425.png\" width=\"673\" border=\"0\" /></a> </p>  <h5>10.Payload control capability</h5>  <p>在数据流建立之后，需要有控制管道负载的能力，包含以下功能</p>  <p>时间同步&#160; 如果有2个sink设备，二者音视频必须同步，实现保真</p>  <p>编码速率控制：因信道条件和电源管理优化控制管道负载</p>  <h5>11.Display Session Teardown</h5>  <p>WFD会话终止，按连接分两种方法</p>  <p>Wifi-direct</p>  <p>跟 wifi p2p规范一样，source和sink有序拆除连接</p>  <p>TDLS</p>  <p>IEEE P802.11z specification规范动作，有序的拆除终止连接</p>','','','2','7','blog','27','1','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('42','SurfaceView, Surface, SurfaceHold的关系','1376644761','<h3><strong>一、Surface</strong> </h3> <p>Surface就是“表面”的意思。在SDK的文档中，对Surface的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”，翻译成中文就是“由屏幕显示内容合成器(screen compositor)所管理的原生缓冲器的句柄”，这句话包括下面两个意思： </p> <p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过Surface（因为Surface是句柄）就可以获得原生缓冲器以及其中的内容。就像在C语言中，可以通过一个文件的句柄，就可以获得文件的内容一样； </p> <p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 原生缓冲器（rawbuffer）是用于保存当前窗口的像素数据的。 </p> <p>引伸地，可以认为Android中的Surface就是一个用来画图形（graphics）或图像（image）的地方。根据Java方面的常规知识，我们知道通常画图是在一个Canvas对象上面进行的，由此，可以推知一个Surface对象中应该包含有一个Canvas对象，事实上的确如此，而且这一点可以很容易通过debug运行程序的方式得到证明（将光标停留在对象变量surface上，会弹出一个对话框，其中红色方框的内容，就表面surface中有一个CompatileCanvas成员变量）当然，看源代码也是可以证明这一点： </p> <p><a href=\"http://zzqhost.com/content/uploadfile/201308/e0734f4b445f7a11c2f7b2681be9638920130816091919.gif\"><img title=\"0_1331661117hbuB\" height=\"114\" alt=\"0_1331661117hbuB\" src=\"http://zzqhost.com/content/uploadfile/201308/67d65cf79045b3c4d2d96ac60abc6d4320130816091920.gif\" width=\"578\" border=\"0\"></a> </p> <p>&nbsp; </p> <p>因此，在前面提及的两个意思的基础上，可以再加上一条： </p> <p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Surface中有一个Canvas成员，专门用于画图的。 </p> <p>所以，Surface中的Canvas成员，是专门用于供程序员画图的场所，就像黑板一样；其中的原生缓冲器是用来保存数据的地方；Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原生缓冲器以及其它方面的内容。 </p> <h3><strong>二、SurfaceView</strong> </h3> <p>SurfaceView，顾名思义就是Surface的View，通过SurfaceView就可以看到Surface的部分或者全部的内容，下面用一个图来形象地描述一下Surface和SurfaceView的关系： </p> <p>&nbsp;<a href=\"http://zzqhost.com/content/uploadfile/201308/48035fe21bffd96183e1b008861b89aa20130816092019.gif\"><img title=\"0_1331661123Ku58\" height=\"311\" alt=\"0_1331661123Ku58\" src=\"http://zzqhost.com/content/uploadfile/201308/e47cdabe156d64810d44544410dc2c4820130816092024.gif\" width=\"473\" border=\"0\"></a> </p> <p>也就是说，Surface是用通过SurfaceView才能展示其中的内容。从这个意思上来说，SurfaceView中的View之确切的含义应该是viewport即“视口”的意思，做过数据库设计的朋友知道，假定一个数据表有20个字段，但我们常常只用到其中的5个字段，那么就可以在原数据表的基础上，通过SQL语句CREATEVIEW来创建只包含那5个字段内容的view。 </p> <p>另一方面，SurfaceView是Android中View的子类。事实上，在Android中所有用于界面展示的类皆为View的子类，包括那些不可见的、各种各样的Layout。 </p> <p>所以说，SurfaceView中的View有两个含义： </p> <p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 视口（viewport）的意思 </p> <p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SurfaceView是View的派生类 </p> <p>在Android中Surface是从Object派生而来，且实现了Parcelable接口。看到Parcelable就让人能很自然地想到数据容器，SurfaceView就是用来展示Surface中的数据的。在这个层面上而言，Surface就是管理数据的地方，SurfaceView就是展示数据的地方。 </p> <h3><strong>三、SurfaceHolder</strong> </h3> <p>SurfaceHolder是一个接口，其作用就像一个关于Surface的监听器。提供访问和控制SurfaceView背后的Surface 相关的方法 （providingaccess and control over this SurfaceView\'s underlying surface），它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView所对应的Surface所对应的SurfaceHolder（有点拗口吧）。 </p> <p>除下面将要提到的SurfaceHolder.Callback外，SurfaceHolder还提供了很多重要的方法，其中最重要的就是： </p> <p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract void <a>addCallback</a>(<a>SurfaceHolder.Callback</a>callback) </p> <p>为SurfaceHolder添加一个SurfaceHolder.Callback回调接口。 </p> <p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract <a>Canvas </a><a>lockCanvas</a>() </p> <p>获取一个Canvas对象，并锁定之。所得到的Canvas对象，其实就是Surface中一个成员。 </p> <p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract <a>Canvas</a><a> lockCanvas</a>(<a>Rect</a>dirty) </p> <p>同上。但只锁定dirty所指定的矩形区域，因此效率更高。 </p> <p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract void <a>unlockCanvasAndPost</a>(<a>Canvas</a>canvas) </p> <p>当修改Surface中的数据完成后，释放同步锁，并提交改变，然后将新的数据进行展示，同时Surface中相关数据会被丢失。 </p> <p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public abstract void setType (int type) </p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置Surface的类型，接收如下的参数： </p> <p>SURFACE_TYPE_NORMAL：用RAM缓存原生数据的普通Surface </p> <p>SURFACE_TYPE_HARDWARE：适用于DMA(Direct memory access )引擎和硬件加速的Surface </p> <p>SURFACE_TYPE_GPU：适用于GPU加速的Surface </p> <p>SURFACE_TYPE_PUSH_BUFFERS：表明该Surface不包含原生数据，Surface用到的数据由其他对象提供，在Camera图像预览中就使用该类型的Surface，有Camera负责提供给预览Surface数据，这样图像预览会比较流畅。如果设置这种类型则就不能调用lockCanvas来获取Canvas对象了。需要注意的是，在高版本的Android SDK中，setType这个方法已经被depreciated了。 </p> <p>2、3、4中的同步锁机制的目的，就是为了在绘制的过程中，Surface中的数据不会被改变。 </p> <p>从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。Model就是模型的意思，或者说是数据模型，或者更简单地说就是数据，也就是这里的Surface；View即视图，代表用户交互界面，也就是这里的SurfaceView；SurfaceHolder很明显可以理解为MVC中的Controller（控制器）。这样看起来三者之间的关系就清楚了很多。 </p> <h3><strong>四、SurfaceHolder.Callback</strong> </h3> <p>前面已经讲到SurfaceHolder是一个接口，它通过回到方法的方式，让我们可以感知到Surface的创建、销毁或者改变。其实这一点是通过其内部的静态子接口SurfaceHolder.Callback来实现的。SurfaceHolder.Callback中定义了三个接口方法： </p> <p>1.&nbsp;&nbsp;&nbsp;&nbsp; abstract void <a>surfaceChanged</a>(<a>SurfaceHolder</a>holder, int format, int width, int height) </p> <p>当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。 </p> <p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract void <a>surfaceCreated</a>(<a>SurfaceHolder</a>holder) </p> <p>当surface对象创建后，该方法就会被立即调用。 </p> <p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract void <a>surfaceDestroyed</a>(<a>SurfaceHolder</a>holder) </p> <p>当surface对象在将要销毁前，该方法会被立即调用。 </p> <p>在Android SDK文档中，关于SurfaceView的描述里面，有一段这样的话： </p> <p>One of the purposes of this class is to provide a surface in which a secondarythread can render into the screen. If you are going to use it this way, youneed to be aware of some threading semantics: </p> <p>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All SurfaceView and SurfaceHolder.Callbackmethods will be called from the thread running the SurfaceView\'s window(typically the main thread of the application). They thus need to correctlysynchronize with any state that is also touched by the drawing thread. </p> <p>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You must ensure that the drawingthread only touches the underlying Surface while it is valid -- betweenSurfaceHolder.Callback.surfaceCreated() andSurfaceHolder.Callback.surfaceDestroyed(). </p> <p>这段话很重要，大致意思如下： </p> <p>这个类的目的之一，就是提供一个可以用另外一个线程（第二个线程）进行屏幕渲染的surface（译注：即UI线程和绘制线程可以分离）。如果你打算这样使用，那么应当注意一些线程方面的语义： </p> <p>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所有SurfaceView和SurfaceHolder.Callback中声明的方法，必须在运行SurfaceView窗口中的线程中调用（典型地，就是应用的主线程。译注：即UI线程），因为它们需要正确地将同时被绘制线程访问的各种状态进行同步。 </p> <p>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 必须保证，只有在背后的Surface有效的时候 – 在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()这两个方法调用之间，访问它。 </p>','','','2','1','blog','5','0','0','0','n','n','y','y','');
INSERT INTO emlog_blog VALUES('39','Windows Live Writer使用代码高亮工具','1375708401','<h3>代码高亮的原理</h3>  <p>&#160;</p>  <p>首先咱们讲一下这个原理，这样就能知其然并知其所以然。</p>  <p>代码高亮，说白了，就是用特殊的HTML标签把代码括起来，你的网站只要支持它就可以了。具体的是什么标记，因为咱们不是学前端编程的，所以也不用搞太明白，如果想知道的话，自己Google。 我查到的结果是好像有四种。</p>  <p>我用的是emlog建的站，它支持pre的标签。 所以我只要找它就够了。</p>  <p>&#160;</p>  <h3>需要在网站上和本地的离线工具都安装插件吗</h3>  <p>这个问题我开始有比较迷惑，后来经过验证，网站的插件和本地的离线工具上的插件都是把代码包括进了 pre 标签中了。 所以我们只要在一个地方加入就行了。</p>  <p>Windows Live Write加入代码高亮插件</p>  <p>我也从网上搜到了好多插件，都不太好用。 好用的只有SyntaxHighlight， 但它不支持中文，于是又搜，终于找到了网友改编的中文版。立即下载之， OK！</p>  <p>附， 中文版 SyntaxHighlight 下载地址， 或者你自己Google之。</p>  <p><a href=\"http://www.cnblogs.com/fuyun/archive/2007/12/08/windows_live_writer_plugins_syntax_highlighting_cn.html\">http://www.cnblogs.com/fuyun/archive/2007/12/08/windows_live_writer_plugins_syntax_highlighting_cn.html</a></p>  <p><a href=\"http://download.csdn.net/download/hb_cattle/298644\">http://download.csdn.net/download/hb_cattle/298644</a></p>  <p>&#160;</p>  <h3>效果</h3>  <p>待补</p>','','','2','8','blog','19','0','0','0','n','n','y','y','');

DROP TABLE IF EXISTS emlog_comment;
CREATE TABLE `emlog_comment` (
  `cid` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `gid` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `pid` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `date` bigint(20) NOT NULL,
  `poster` varchar(20) NOT NULL DEFAULT '',
  `comment` text NOT NULL,
  `mail` varchar(60) NOT NULL DEFAULT '',
  `url` varchar(75) NOT NULL DEFAULT '',
  `ip` varchar(128) NOT NULL DEFAULT '',
  `hide` enum('n','y') NOT NULL DEFAULT 'n',
  PRIMARY KEY (`cid`),
  KEY `gid` (`gid`),
  KEY `date` (`date`),
  KEY `hide` (`hide`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

INSERT INTO emlog_comment VALUES('1','31','0','1373896976','david','不错不错,　受益匪浅','40772568@qq.com','','106.120.78.144','n');
INSERT INTO emlog_comment VALUES('2','35','0','1375149195','Vivien','很棒，连我不是做IT的，都看懂了','525635358@qq.com','','58.210.93.146','n');
INSERT INTO emlog_comment VALUES('3','9','0','1375727460','abercrombie soldes','配置Android开发环境 - 张志强的博客 <a href=\"http://www.chaussresboutique.info/\" target=\"_blank\">abercrombie pas cher</a>','erpwdskiz@gmail.com','http://abercrombieonlineshops.webs.com/','222.77.247.48','n');
INSERT INTO emlog_comment VALUES('4','9','0','1376104723','oakley sunglasses','配置Android开发环境 - 张志强的博客 oakley sunglasses online http://www.discountsunglassesshopoutlet.com/','oevcpyniu@gmail.com','http://www.discountsunglassesshopoutlet.com/','205.164.24.90','n');
INSERT INTO emlog_comment VALUES('5','19','0','1376260888','oakley sunglasses','ramfs,tmpfs,rootfs,initramfs和romfs - 张志强的博客 oakley sunglasses http://www.discountsunglassesshopoutlet.com/','mybmzr@gmail.com','http://www.discountsunglassesshopoutlet.com/','205.164.24.90','n');

DROP TABLE IF EXISTS emlog_options;
CREATE TABLE `emlog_options` (
  `option_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `option_name` varchar(255) NOT NULL,
  `option_value` longtext NOT NULL,
  PRIMARY KEY (`option_id`),
  KEY `option_name` (`option_name`)
) ENGINE=MyISAM AUTO_INCREMENT=56 DEFAULT CHARSET=utf8;

INSERT INTO emlog_options VALUES('1','blogname','张志强的博客');
INSERT INTO emlog_options VALUES('2','bloginfo','点滴记忆');
INSERT INTO emlog_options VALUES('3','site_title','');
INSERT INTO emlog_options VALUES('4','site_description','');
INSERT INTO emlog_options VALUES('5','site_key','android,multimedia,zzqhost');
INSERT INTO emlog_options VALUES('6','log_title_style','1');
INSERT INTO emlog_options VALUES('7','blogurl','http://zzqhost.com/');
INSERT INTO emlog_options VALUES('8','icp','');
INSERT INTO emlog_options VALUES('9','footer_info','');
INSERT INTO emlog_options VALUES('10','admin_perpage_num','15');
INSERT INTO emlog_options VALUES('11','rss_output_num','10');
INSERT INTO emlog_options VALUES('12','rss_output_fulltext','y');
INSERT INTO emlog_options VALUES('13','index_lognum','10');
INSERT INTO emlog_options VALUES('14','index_comnum','10');
INSERT INTO emlog_options VALUES('15','index_twnum','10');
INSERT INTO emlog_options VALUES('16','index_newtwnum','5');
INSERT INTO emlog_options VALUES('17','index_newlognum','5');
INSERT INTO emlog_options VALUES('18','index_randlognum','5');
INSERT INTO emlog_options VALUES('19','index_hotlognum','5');
INSERT INTO emlog_options VALUES('20','comment_subnum','20');
INSERT INTO emlog_options VALUES('21','nonce_templet','TangStyle');
INSERT INTO emlog_options VALUES('22','admin_style','default');
INSERT INTO emlog_options VALUES('23','tpl_sidenum','1');
INSERT INTO emlog_options VALUES('24','comment_code','n');
INSERT INTO emlog_options VALUES('25','comment_needchinese','y');
INSERT INTO emlog_options VALUES('26','comment_interval','15');
INSERT INTO emlog_options VALUES('27','isgravatar','y');
INSERT INTO emlog_options VALUES('28','isthumbnail','y');
INSERT INTO emlog_options VALUES('29','comment_paging','y');
INSERT INTO emlog_options VALUES('30','comment_pnum','15');
INSERT INTO emlog_options VALUES('31','comment_order','newer');
INSERT INTO emlog_options VALUES('32','login_code','n');
INSERT INTO emlog_options VALUES('33','reply_code','n');
INSERT INTO emlog_options VALUES('34','iscomment','y');
INSERT INTO emlog_options VALUES('35','ischkcomment','n');
INSERT INTO emlog_options VALUES('36','ischkreply','n');
INSERT INTO emlog_options VALUES('37','isurlrewrite','0');
INSERT INTO emlog_options VALUES('38','isalias','n');
INSERT INTO emlog_options VALUES('39','isalias_html','n');
INSERT INTO emlog_options VALUES('40','isgzipenable','n');
INSERT INTO emlog_options VALUES('41','istrackback','n');
INSERT INTO emlog_options VALUES('42','isxmlrpcenable','y');
INSERT INTO emlog_options VALUES('43','ismobile','y');
INSERT INTO emlog_options VALUES('44','istwitter','y');
INSERT INTO emlog_options VALUES('45','istreply','y');
INSERT INTO emlog_options VALUES('46','topimg','content/templates/default/images/top/default.jpg');
INSERT INTO emlog_options VALUES('47','custom_topimgs','a:0:{}');
INSERT INTO emlog_options VALUES('48','timezone','8');
INSERT INTO emlog_options VALUES('49','active_plugins','a:2:{i:0;s:13:\"tips/tips.php\";i:1;s:39:\"syntaxHighlighter/syntaxHighlighter.php\";}');
INSERT INTO emlog_options VALUES('50','widget_title','a:13:{s:7:\"blogger\";s:12:\"个人资料\";s:8:\"calendar\";s:6:\"日历\";s:7:\"twitter\";s:12:\"最新微语\";s:3:\"tag\";s:6:\"标签\";s:4:\"sort\";s:6:\"分类\";s:7:\"archive\";s:6:\"存档\";s:7:\"newcomm\";s:12:\"最新评论\";s:6:\"newlog\";s:12:\"最新文章\";s:10:\"random_log\";s:12:\"随机文章\";s:6:\"hotlog\";s:12:\"热门文章\";s:4:\"link\";s:6:\"链接\";s:6:\"search\";s:6:\"搜索\";s:11:\"custom_text\";s:15:\"自定义组件\";}');
INSERT INTO emlog_options VALUES('51','custom_widget','a:0:{}');
INSERT INTO emlog_options VALUES('52','widgets1','a:4:{i:0;s:4:\"sort\";i:1;s:7:\"archive\";i:2;s:6:\"hotlog\";i:3;s:4:\"link\";}');
INSERT INTO emlog_options VALUES('53','widgets2','');
INSERT INTO emlog_options VALUES('54','widgets3','');
INSERT INTO emlog_options VALUES('55','widgets4','');

DROP TABLE IF EXISTS emlog_navi;
CREATE TABLE `emlog_navi` (
  `id` smallint(4) unsigned NOT NULL AUTO_INCREMENT,
  `naviname` varchar(30) NOT NULL DEFAULT '',
  `url` varchar(75) NOT NULL DEFAULT '',
  `newtab` enum('n','y') NOT NULL DEFAULT 'n',
  `hide` enum('n','y') NOT NULL DEFAULT 'n',
  `taxis` smallint(4) unsigned NOT NULL DEFAULT '0',
  `isdefault` enum('n','y') NOT NULL DEFAULT 'n',
  `type` tinyint(3) unsigned NOT NULL DEFAULT '0',
  `type_id` mediumint(8) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

INSERT INTO emlog_navi VALUES('1','首页','','n','n','0','y','1','0');
INSERT INTO emlog_navi VALUES('2','微语','t','n','n','1','y','2','0');
INSERT INTO emlog_navi VALUES('3','登录','admin','n','n','100','y','3','0');
INSERT INTO emlog_navi VALUES('20','自我介绍','','n','n','11','n','5','33');

DROP TABLE IF EXISTS emlog_reply;
CREATE TABLE `emlog_reply` (
  `id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `tid` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `date` bigint(20) NOT NULL,
  `name` varchar(20) NOT NULL DEFAULT '',
  `content` text NOT NULL,
  `hide` enum('n','y') NOT NULL DEFAULT 'n',
  `ip` varchar(128) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  KEY `gid` (`tid`),
  KEY `hide` (`hide`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

INSERT INTO emlog_reply VALUES('1','2','1373896926','xyz','恭喜恭喜!','n','');

DROP TABLE IF EXISTS emlog_sort;
CREATE TABLE `emlog_sort` (
  `sid` tinyint(3) unsigned NOT NULL AUTO_INCREMENT,
  `sortname` varchar(255) NOT NULL DEFAULT '',
  `alias` varchar(200) NOT NULL DEFAULT '',
  `taxis` smallint(4) unsigned NOT NULL DEFAULT '0',
  `pid` tinyint(3) unsigned NOT NULL DEFAULT '0',
  `description` text NOT NULL,
  PRIMARY KEY (`sid`)
) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

INSERT INTO emlog_sort VALUES('1','Android代码研究','','1','0','');
INSERT INTO emlog_sort VALUES('2','Android环境配置','','2','0','');
INSERT INTO emlog_sort VALUES('3','QTCreater','','10','0','');
INSERT INTO emlog_sort VALUES('4','Linux学习笔记','','20','0','');
INSERT INTO emlog_sort VALUES('5','多媒体','','30','0','');
INSERT INTO emlog_sort VALUES('6','Git','','40','0','');
INSERT INTO emlog_sort VALUES('7','Android新技术','','3','0','');
INSERT INTO emlog_sort VALUES('8','建站笔记','','50','0','');

DROP TABLE IF EXISTS emlog_link;
CREATE TABLE `emlog_link` (
  `id` smallint(4) unsigned NOT NULL AUTO_INCREMENT,
  `sitename` varchar(30) NOT NULL DEFAULT '',
  `siteurl` varchar(75) NOT NULL DEFAULT '',
  `description` varchar(255) NOT NULL DEFAULT '',
  `hide` enum('n','y') NOT NULL DEFAULT 'n',
  `taxis` smallint(4) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

INSERT INTO emlog_link VALUES('2','张志强的csdn博客','http://blog.csdn.net/zzqhost','张志强的csdn博客','n','0');
INSERT INTO emlog_link VALUES('3','张志强的163博客','http://zzqhost.blog.163.com/','','n','0');
INSERT INTO emlog_link VALUES('4','张志强的github博客','http://zzqhost.github.io/hostwiki','','n','0');

DROP TABLE IF EXISTS emlog_tag;
CREATE TABLE `emlog_tag` (
  `tid` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `tagname` varchar(60) NOT NULL DEFAULT '',
  `gid` text NOT NULL,
  PRIMARY KEY (`tid`),
  KEY `tagname` (`tagname`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

INSERT INTO emlog_tag VALUES('1','android',',29,30,31,32,35,42,');
INSERT INTO emlog_tag VALUES('2','Content-Type',',29,');
INSERT INTO emlog_tag VALUES('3','mime',',29,');
INSERT INTO emlog_tag VALUES('4','git',',30,');
INSERT INTO emlog_tag VALUES('5','miracast',',31,32,35,');
INSERT INTO emlog_tag VALUES('6','DLAN',',32,');
INSERT INTO emlog_tag VALUES('7','AirPlay',',32,');
INSERT INTO emlog_tag VALUES('8','wifi-display',',35,');
INSERT INTO emlog_tag VALUES('9','surface',',42,');
INSERT INTO emlog_tag VALUES('10','surfacehold',',42,');

DROP TABLE IF EXISTS emlog_trackback;
CREATE TABLE `emlog_trackback` (
  `tbid` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `gid` mediumint(8) unsigned NOT NULL DEFAULT '0',
  `title` varchar(255) NOT NULL DEFAULT '',
  `date` bigint(20) NOT NULL,
  `excerpt` text NOT NULL,
  `url` varchar(255) NOT NULL DEFAULT '',
  `blog_name` varchar(255) NOT NULL DEFAULT '',
  `ip` varchar(16) NOT NULL DEFAULT '',
  PRIMARY KEY (`tbid`),
  KEY `gid` (`gid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;


DROP TABLE IF EXISTS emlog_twitter;
CREATE TABLE `emlog_twitter` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text NOT NULL,
  `img` varchar(200) DEFAULT NULL,
  `author` int(10) NOT NULL DEFAULT '1',
  `date` bigint(20) NOT NULL,
  `replynum` mediumint(8) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `author` (`author`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

INSERT INTO emlog_twitter VALUES('1','使用微语记录您身边的新鲜事','','1','1373369341','0');
INSERT INTO emlog_twitter VALUES('2','终于把我的新博客搞好了,　发贴庆祝一下!!![呵呵]','','1','1373896811','1');

DROP TABLE IF EXISTS emlog_user;
CREATE TABLE `emlog_user` (
  `uid` tinyint(3) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) NOT NULL DEFAULT '',
  `password` varchar(64) NOT NULL DEFAULT '',
  `nickname` varchar(20) NOT NULL DEFAULT '',
  `role` varchar(60) NOT NULL DEFAULT '',
  `photo` varchar(255) NOT NULL DEFAULT '',
  `email` varchar(60) NOT NULL DEFAULT '',
  `description` varchar(255) NOT NULL DEFAULT '',
  PRIMARY KEY (`uid`),
  KEY `username` (`username`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

INSERT INTO emlog_user VALUES('1','zzqhost','$P$BvMK4GZjH2fzV6AiqPJTU2pCqw2Q7e1','','admin','','','');
INSERT INTO emlog_user VALUES('2','zhangzhiqiang','$P$BrIdH4gtSO86IZlzQ4xMbDP.YiEGfS0','张志强','writer','../content/uploadfile/201307/thum-923c1373420698.jpg','zzqhost@163.com','');


#the end of backup